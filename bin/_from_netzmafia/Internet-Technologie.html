<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252"><script type="text/javascript" src="Internet-Technologie-Dateien/bundle-playback.js" charset="utf-8"></script>
<script type="text/javascript" src="Internet-Technologie-Dateien/wombat.js" charset="utf-8"></script>
<script>window.RufflePlayer=window.RufflePlayer||{};window.RufflePlayer.config={"autoplay":"on","unmuteOverlay":"hidden"};</script>
<script type="text/javascript" src="Internet-Technologie-Dateien/ruffle.js"></script>
<script type="text/javascript">
    __wm.init("https://web.archive.org/web");
  __wm.wombat("http://www.netzmafia.de/skripten/server/server2.html","20070823185916","https://web.archive.org/","web","https://web-static.archive.org/_static/",
	      "1187895556");
</script>
<link rel="stylesheet" type="text/css" href="Internet-Technologie-Dateien/banner-styles.css">
<link rel="stylesheet" type="text/css" href="Internet-Technologie-Dateien/iconochive.css">
<!-- End Wayback Rewrite JS Include -->
<title>Internet-Technologie</title></head>
<body text="#000000" bgcolor="#FFFFFF" link="#0000FF" vlink="#FF00FF" alink="#FF0000">
<center><table width="90%" border="0"><tbody><tr><td align="left"><img src="Internet-Technologie-Dateien/netzwerk.gif"></td>
<td align="right"><h3>Internet-Technologie</h3>
<b><i>Prof. Jürgen Plate</i></b></td>
</tr></tbody></table></center><hr>

<h1>2 Standard-Tools für Netzwerker</h1>

<a name="2.1"></a>
<h2>2.1 Client und Server</h2>
Die meisten Anwendungen in TCP/IP-Netzenfunktionieren nach dem Client-Server-Prinzip. 
Im einfachsten Fall kommunizieren dabei zwei Rechner miteinander, wobei auf dem einen 
ein Client- und auf dem anderen der Serverprozeß laufen. 
Der Client interpretiert die Eingaben des Anwenders und führt die Anweisung 
entweder selbst aus oder setzt sie in Anweisungen um und schickt sie als Auftrag dem 
Server. Von diesem erhält er dann die Ergebnisse des Auftrags zurück (oder nur 
eine Meldung über die erfolgreiche oder fehlerhafte Ausführung).
Der Server kann dabei weit entfernt sein, sich im gleichen lokalen Netz oder sogar auf 
dem gleichen Rechner wie der Client befinden. Auf einem Rechner können mehrere 
Server-Programme laufen - ein Rechner kann damit mehrere Server-Dienste zur 
Verfügung stellen. Wenn wir von Servern reden, sollten wir deshalb unterscheiden, 
ob wir von einem Server-Rechner reden oder von einem Server-Dienst bzw. dem entsprechenden 
Server-Programm. Der Client-Prozeß wird in der Regel auch erst bei Bedarf 
gestartet und versucht dann, Kontakt mit dem Serverprozeß aufzunehmen.
Dies setzt natürlich voraus, daß der Server schon 'wartet',
d. h. ständig an einem System läuft. 
<p>
Der Server (bzw. das Server-Programm) stellt also einen <b>Dienst</b> zur Verfügung, 
der vom Client angefordert werden kann. Client und Server unterhalten sich dabei in einer 
speziellen Sprache - dem entsprechenden Dienstprotokoll. So gibt es ein Protokoll zwischen 
dem Mail-Server und dem Mail-Client (z.B. SMTP, IMAP oder POP3), eines für den 
Dateiaustausch zwischen FTP-Client und FFP-Server, ein weiteres für WWW u.s.w.
</p><p>

<a name="2.2"></a>
</p><h2>2.2 Ports - Eingänge für Server</h2>
Unterschiedliche Serverprogramme bzw. Serverdienste werden innerhalb eines Rechners 
durch unterschiedliche Ports angesprochen, wobei ein Port eine Art logischer 
Kommunikationseingang im Rechner bzw. Betriebssystem ist. Den verschiedenen Servern 
(bzw. Diensten) sind im Standardfall feste Portnummern zugeordnet. Welcher 
Port für welchen Dienst verwendet wird, braucht uns als Endbenutzer jedoch in 
der Regel nicht kümmern. Der Client sollte dies wissen. Nur in Ausnahmefällen, 
wenn eine besondere Server-Variante oder ein anderer Port benutzt wird, gibt man im 
Client den vom Standard abweichenden Port an.
<p>

<a name="2.3"></a>
</p><h2>2.3 Dokumentation</h2>
Alle Protokolle und Vereinbarungen über Internet-Protokolle sind in
Dokumenten festgehalten, die den Namen 'Request for Comment', kurz RFC,
tragen. Die Dokumente sind durchnumeriert und im Netz frei erhältlich, 
können aber auch auf CD-ROM erworben werden. Ein RFC wird auch nicht 
ungültig, sondern bei Änderungen im Protokoll durch ein 
Nachfolgedokument ('Son of RFC xxx') ergänzt
oder ersetzt. Die RFCs enthalten nicht nur technische Dokumente,
sondern auch für den technischen Laien geeignete
Bedienungsanleitungen. Wer sich mit den RFCs zu gebräuchlichen
Diensten beschäftigt, wird feststellen, daß
viele Protokolle sehr einfach gehalten sind und daher die
Implementierung auf verschiedenen Rechnern schnell möglich ist.
Die RFC werden vom InterNIC verwaltet.
<p>

<a name="2.4"></a>
</p><h2>2.4 Standard-Tools</h2>
Viele der gebräuchlichen Internet-Protokolle sind einfache Wechselgespräche,
die man fast schon mit Shell-Skripten implementieren kann. Dieser Teil beschreibt 
einige kleine Tools, die man zum Zuschauen und Mitmachen braucht, und zeigt,
wie einfach FTP, HTTP und andere Protokolle tatsächlich aufgebaut sind.
<p>

</p><h3>ping</h3>
Ob man ein anderes System erreichen kann, untersucht man in der Regel mit
ping. Das Programm ping erzeugt ICMP-Echo-Request-Pakete, die mit 
ICMP-Echo-Response-Paketen beantwortet werden, wenn sie das angegebene 
System erreichen. 
<pre>$ ping www.e-technik.fh-muenchen.de
PING www.e-technik.fh-muenchen.de (129.187.206.140): 56 data bytes
64 bytes from 129.187.206.140: icmp_seq=0 ttl=242 time=48.9 ms
64 bytes from 129.187.206.140: icmp_seq=1 ttl=242 time=41.9 ms
64 bytes from 129.187.206.140: icmp_seq=2 ttl=242 time=41.3 ms
64 bytes from 129.187.206.140: icmp_seq=3 ttl=242 time=39.9 ms
64 bytes from 129.187.206.140: icmp_seq=4 ttl=242 time=44.9 ms
64 bytes from 129.187.206.140: icmp_seq=5 ttl=242 time=42.9 ms
64 bytes from 129.187.206.140: icmp_seq=6 ttl=242 time=45.4 ms
64 bytes from 129.187.206.140: icmp_seq=7 ttl=242 time=40.5 ms
64 bytes from 129.187.206.140: icmp_seq=8 ttl=242 time=41.4 ms
64 bytes from 129.187.206.140: icmp_seq=9 ttl=242 time=42.3 ms

--- www.e-technik.fh-muenchen.de ping statistics ---
10 packets transmitted, 10 packets received, 0% packet loss
round-trip min/avg/max = 39.9/42.9/48.9 ms
</pre>
<p>

</p><h3>arp</h3>
Bei einigen Netzproblemen kann es aufschlußreich sein, einen Blick auf 
die ARP-Tabelle des Kernels zu werfen oder sie sogar zu verändern. 
Das "Address Resolution Protocol" dient der Zuordnung von Internet-Adressen zu 
Ethernet-Adressen. Zu diesern Zwecke existiert eine Adreßumwandlungstabelle 
(adress-translation table), die normalerweise vom ARP selbständig aktualisiert 
wird. Die Kommandozeilenoptionen von ARP lauten:
<pre>arp [-v] [-t hwtype] -a [hostname] 
arp [-v] [-t hwtype] -s hostname hwaddr 
</pre>
Alle hostname-Argumente können als symbolische Hostnamen oder als IP-Adressen angegeben werden.
<p>
Der erste Aufruf gibt den ARP-Eintrag für die angegebene IP-Adresse bzw. Hostnamen aus. 
Fehlt <tt>hostname</tt>, werden Informationen über alle bekannten Hosts ausgegeben. 
Zum Beispiel ergibt die Ausgabe von <i>arp</i> auf <i>www.netzmafia.de</i> etwa folgendes:
</p><pre>arp
Address                  HWtype  HWaddress           Flags Mask  Iface
129.187.206.254          ether   00:04:DE:FE:78:00   C           eth0
ns.e-technik.fh-muenche  ether   00:07:E9:24:EC:15   C           eth0
proxy1.e-technik.fh-mue  ether   00:07:E9:24:EC:15   C           eth0
web1.e-technik.fh-muenc  ether   00:07:E9:24:EB:F5   C           eth0
</pre>
Die Ausgabe kann mit der <b>-t</b>-Option auch auf bestimmte Hardwaretypen beschränkt werden.
Als Argument geben Sie <i>ether</i>, <i>ax25</i> oder <i>pronet</i> an, was für 10 Mbps Ethernet, 
AMPR AX.25 und IEEE 802.5 Token Ring steht.
<p>
Die Option <b>-s</b> dient dazu, die Hardwareadresse von <tt>hostname</tt> manuell in die 
ARP-Tabelle einzutragen. Das Argument <tt>hwaddr</tt> spezifiziert die Hardwareadresse, 
die normalerweise als Ethernet-Adresse aus sechs Byte in hexadezimaler Notation angegeben ist. 
Sie können solche Adressen auch bei anderen Hardwaretypen verwenden, wenn Sie zusätzlich die 
Option <b>-t</b> angeben.
Die Festverdrahtung von Hardwareadressen im ARP-Cache ist eine drastische Maßnahme, um Maschinen 
aus Ihrem Ethernet daran zu hindern, sich als jemand anderes auszugeben.
</p><p>
Wenn Sie <i>arp</i> mit der Option <b>-d</b> aufrufen, entfernt es alle Einträge für einen bestimmten 
Host. Es kann dazu benutzt werden, das Interface anzuweisen, eine bereits angeforderte Hardwareadresse 
einer IP-Adresse nochmals anzufordern, und ist besonders dann nützlich, wenn ein fehlerhaft konfiguriertes 
System falsche ARP-Informationen sendet (natürlich muß zuerst das fehlerhafte System erneut konfiguriert 
werden).
</p><p>
Mit der Option "-a" wird der aktuelle Inhalt der Tabelle ausgegeben, z.B.:
</p><pre>arp -a
Net to Media Table
Device   IP Address  -------             Mask      Flags   Phys Addr 
------ --------------------------- --------------- ----- -----------------
le0    brokrz.lrz-muenchen.de      255.255.255.255       00:00:a2:0f:76:97
le0    infoserv.rz.fh-muenchen.de  255.255.255.255       00:e0:29:06:18:d3
le0    flynt.rz.fh-muenchen.de     255.255.255.255       00:e0:29:08:49:f1
le0    kobra.rz.fh-muenchen.de     255.255.255.255       00:08:c7:a9:6c:cc
le0    netmon.rz.fh-muenchen.de    255.255.255.255       00:e0:29:0e:83:92
le0    linux4.rz.fh-muenchen.de    255.255.255.255       00:00:c0:93:19:d3
le0    linux5.rz.fh-muenchen.de    255.255.255.255       00:00:c0:37:19:d3
le0    door2.rz.fh-muenchen.de     255.255.255.255       00:00:c0:3f:fb:a7
le0    wapserv                     255.255.255.255 SP    08:00:20:23:02:88
le0    sun10.rz.fh-muenchen.de     255.255.255.255       08:00:20:86:ce:5e
le0    kiosk1.rz.fh-muenchen.de    255.255.255.255       00:00:c0:60:af:d7
le0    satellit.rz.fh-muenchen.de  255.255.255.255       08:00:20:71:77:b4
le0    kaputt.rz.fh-muenchen.de    255.255.255.255       00:50:56:82:f0:f0
</pre>
<p>

</p><h3>netstat</h3>
Mit Hilfe des Programms netstat können Status-Information über TCP/IP ausgegeben 
werden. Bei der Fehlersuche kann sich dieses Programm ebenfalls als durchaus 
nützlich erweisen. 

<h4>Anzeigen der Routing-Tabelle</h4>
Wenn Sie <i>netstat</i> mit dem Flag <b>-r</b> aufrufen, gibt es die Routing-Tabellen 
des Kernels aus; ähnlich, wie Sie es oben bereits bei <i>route</i> gesehen haben. 
Zum Beispiel:
<pre>netstat -nr 

Kernel IP Routentabelle
Ziel            Router          Genmask         Flags   MSS Fenster irtt Iface
129.187.206.0   0.0.0.0         255.255.255.0   U         0 0          0 eth0
192.168.1.0     0.0.0.0         255.255.255.0   U         0 0          0 eth1
0.0.0.0         129.187.206.254 0.0.0.0         UG        0 0          0 eth0
</pre>
<p>
Die Option <b>-n</b> sorgt zusätzlich dafür, daß <i>netstat</i> die Adressen statt als 
symbolische Host- und Netzwerknamen direkt in dezimaler Notation ausgibt. Das ist dann 
nützlich, wenn Sie verhindern wollen, daß langwierige Adreßauflösungsanfragen über das 
Netzwerk ausgeführt werden, zum Beispiel beim DNS- oder NIS-Server.
Die zweite Spalte der <i>netstat</i>-Ausgabe zeigt jeweils das Ziel der Route an. Die 
zweite Spalte gibt das Gateway an, auf das der Routing-Eintrag zeigt. Wird kein Gateway 
verwendet, wird statt dessen ein Sternchen ausgegeben. Die dritte Spalte gibt Auskunft 
über die "Allgemeinheit" der Route, d.h. deren Netzmaske. Wenn der Kernel eine IP-Adresse
erhält, für die er eine angemessene Route finden soll, dann durchsucht er alle Einträge 
in der Routing-Tabelle und führt eine bitweise UND-Verknüpfung mit der Adresse und der 
Genmask durch, bevor er sie mit dem Ziel der Route vergleicht.
Die vierte Spalte zeigt verschiedene Flags, die die Route näher charakterisieren.
</p><p>
<table border="1" cellpadding="3" cellspacing="0" width="80%"> 
<tbody><tr><td><tt>G</tt></td><td>
Die Route geht durch ein Gateway.
</td></tr>

<tr><td><tt>U</tt></td><td>
Das zu verwendende Interface ist aktiv.
</td></tr>

<tr><td><tt>H</tt></td><td>
Die Route zeigt auf einen einzelnen Host, wie das z.B. beim Loopback-Eintrag <i>127.0.0.1</i> der Fall ist.
</td></tr>

<tr><td><tt>D</tt></td><td>
Diese Route wurde dynamisch erzeugt. Dieses Flag ist gesetzt, wenn der Tabelleneintrag von einem 
Routing-Dämon wie <i>gated</i> oder durch eine ICMP-Redirect-Nachricht generiert wurde.
</td></tr>

<tr><td><tt>M</tt></td><td>
Dieses Flag ist gesetzt, wenn der entsprechende Tabelleneintrag durch eine ICMP-Redirect-Nachricht 
verändert wurde. Der Tabelleneintrag wurde durch einen ICMP-Redirect modifiziert.
</td></tr>

<tr><td><tt>!</tt></td><td>
Alle Datagramme werden verworfen.
</td></tr>
</tbody></table>
</p><p>
Die nächsten drei Spalten geben Auskunft über die maximale Segmentgröße (MSS, <i>Maximum 
Segment Size</i>), das Fenster sowie über die Anfangsumlaufzeit (irtt, <i>initial round trip 
time</i>), die auf die über diese Route etablierten TCP-Verbindungen anzuwenden sind. Die 
MSS bezeichnet den Umfang des größten IP-Pakets, das der Kernel über diese Route verschickt. 
Mit dem Fenster ist die maximale Datenmenge gemeint, die von einem Remote-Host auf einmal 
empfangen werden kann. Das TCP-Protokoll stellt sicher, daß die Daten zwischen den Hosts 
zuverlässig übertragen werden. Falls Datenpakete unterwegs verlorengehen, wird die übertragung 
dieser fehlenden Pakete automatisch wiederholt. Das TCP-Protokoll ermittelt am Anfang einer 
übertragung, wie lange das gesendete Datenpaket zum Remote-Host braucht, und ermittelt aus 
der Zeit bis zur Rückantwort einen Wert, der für die weitere Datenübertragung als Maß dient, 
ob ein IP-Paket ggf. wiederholt werden muß. Diese Zeit wird als <i>round trip time</i> bezeichnet. 
Der Vorgabewert wird vom TCP-Protokoll beim erstmaligen Verbindungsaufbau benutzt.  
Nullwerte in diesen Spalten bedeuten, daß Standardwerte benutzt werden.
Schließlich gibt das letzte Feld die Netzwerkschnittstelle an, die die Route benutzt.
</p><p>
</p><h4>Anzeige der Interface-Statistiken</h4>
Wenn Sie <i>netstat</i> mit dem Flag <b>-i</b> aufrufen, gibt es die Statistiken für die 
gerade aktiven Netzwerkschnittstellen aus. Geben Sie außerdem das Flag <b>-a</b> mit an, 
werden <i>alle</i> im Kernel vorhandenen Schnittstellen ausgegeben, nicht nur die 
konfigurierten.Zum Beispiel:
<pre>netstat -i 
Kernel Schnittstellentabelle
Iface   MTU Met   RX-OK RX-ERR RX-DRP RX-OVR   TX-OK TX-ERR TX-DRP TX-OVR Flg
eth0   1500   0   31746      0      0      0   14928      0      0      0 BMRU
eth0:  1500   0     - keine Statistiken verfügbar -                    BMRU
eth0:  1500   0     - keine Statistiken verfügbar -                    BMRU
eth0:  1500   0     - keine Statistiken verfügbar -                    BMRU
eth0:  1500   0     - keine Statistiken verfügbar -                    BMRU
eth0:  1500   0     - keine Statistiken verfügbar -                    BMRU
eth0:  1500   0     - keine Statistiken verfügbar -                    BMRU
eth0:  1500   0     - keine Statistiken verfügbar -                    BMRU
eth0:  1500   0     - keine Statistiken verfügbar -                    BMRU
eth0:  1500   0     - keine Statistiken verfügbar -                    BMRU
eth1   1500   0       0      0      0      0    8691      0      0      0 BMRU
lo    16436   0     966      0      0      0     966      0      0      0 LRU
</pre>
Die Spalten <tt>MTU</tt> und <tt>Met</tt> geben die aktuelle MTU und Metrik des Interface 
an. Die mit <tt>RX</tt> bzw. <tt>TX</tt> überschriebenen Spalten geben an, wie viele Pakete 
fehlerfrei empfangen bzw. gesendet wurden (<tt>RX-OK</tt>/<tt>TX-OK</tt>), wie viele 
beschädigt waren (<tt>RX-ERR</tt>/<tt>TX-ERR</tt>), wie viele verworfen werden mußten 
(<tt>RX-DRP</tt>/<tt>TX-DRP</tt>) und wie viele aufgrund eines Overruns verlorengingen 
(<tt>RX-OVR</tt>/<tt>TX-OVR</tt>).
Die letzte Spalte zeigt wieder die Flags an, die für die Schnittstelle gesetzt sind. 
Das sind einbuchstabige Versionen der langen Flag-Namen, die <i>ifconfig</i> ausgibt:
<p>
<table border="1" cellpadding="3" cellspacing="0"> 
<tbody><tr><td><tt>B</tt></td><td>
Eine Broadcast-Adresse wurde gesetzt.
</td></tr>

<tr><td><tt>L</tt></td><td>
Die Schnittstelle ist ein Loopback-Device.
</td></tr>

<tr><td><tt>M</tt></td><td>
Alle Pakete werden empfangen (promiskuöser Modus).
</td></tr>

<tr><td><tt>O</tt></td><td>
ARP ist an dieser Schnittstelle abgeschaltet.
</td></tr>

<tr><td><tt>P</tt></td><td>
Es handelt sich um eine Punkt-zu-Punkt-Verbindung.
</td></tr>

<tr><td><tt>R</tt></td><td>
Die Schnittstelle ist "running".
</td></tr>

<tr><td><tt>U</tt></td><td>
Die Schnittstelle ist aktiv ("up").
</td></tr>
</tbody></table>
</p><p>
</p><h4>Anzeigen der Verbindungen</h4>
<i>netstat</i> bietet eine Reihe von Optionen, mit denen Sie aktive und passive 
Sockets auflisten können. Die Argumente <b>-t</b>, <b>-u</b>, <b>-w</b> und 
<b>-x</b> zeigen aktive TCP-, UDP-, RAW- und UNIX-Sockets. Wenn Sie zusätzlich 
<b>-a</b> angeben, sehen Sie außerdem die Sockets, die gerade auf eine Verbindung 
warten. Auf diese Weise erhalten Sie eine Liste aller Server, die derzeit auf 
Ihrem System laufen.
<pre>netstat -ta 
Aktive Internetverbindungen (Server und stehende Verbindungen)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 *:imaps                 *:*                     LISTEN
tcp        0      0 *:mysql                 *:*                     LISTEN
tcp        0      0 vweb1.ee.fhm.edu:7788   *:*                     LISTEN
tcp        0      0 *:pop3                  *:*                     LISTEN
tcp        0      0 *:imap                  *:*                     LISTEN
tcp        0      0 *:sunrpc                *:*                     LISTEN
tcp        0      0 *:www-http              *:*                     LISTEN
tcp        0      0 *:bpcd                  *:*                     LISTEN
tcp        0      0 *:vopied                *:*                     LISTEN
tcp        0      0 *:smtp                  *:*                     LISTEN
tcp        0      0 *:bpjava-msvc           *:*                     LISTEN
tcp        0      0 ehg.e-technik.fh-m:smtp mailrelay2.rz.fh-:48063 VERBUNDEN
tcp        0      0 *:ssh                   *:*                     LISTEN
tcp        0   1208 vweb.e-technik.fh-m:ssh diale071.ppp.lrz-:58198 VERBUNDEN
tcp        0      0 vweb.e-technik.fh-m:ssh menetekel.e-techn:32862 VERBUNDEN
</pre>
Man sieht, daß die meisten Server einfach auf eine eingehende Verbindung warten, 
da sie sich im Zustand <tt>LISTEN</tt> befinden. 
<p>
Wenn Sie <i>netstat</i> nur mit der Option <b>-a</b> aufrufen, zeigt es eine 
Liste aller Sockets aus allen Familien:
</p><pre>Active Internet connections (including servers)
Proto Recv-Q Send-Q Local Address          Foreign Address        (State)       User
tcp        0      0 *:netbios-ssn          *:*                    LISTEN        root       
tcp        0      0 *:nntp                 *:*                    LISTEN        root       
tcp        0      0 *:auth                 *:*                    LISTEN        root       
tcp        0      0 *:sunrpc               *:*                    LISTEN        root       
tcp        0      0 *:pop3                 *:*                    LISTEN        root       
tcp        0      0 *:www                  *:*                    LISTEN        root       
tcp        0      0 *:finger               *:*                    LISTEN        root       
tcp        0      0 *:midinet              *:*                    LISTEN        root       
tcp        0      0 *:http-rman            *:*                    LISTEN        root       
tcp        0      0 *:btx                  *:*                    LISTEN        root       
tcp        0      0 *:smtp                 *:*                    LISTEN        root       
tcp        0      0 *:telnet               *:*                    LISTEN        root       
tcp        0      0 *:ftp                  *:*                    LISTEN        root       
tcp        0      0 *:netstat              *:*                    LISTEN        root       
tcp        0      0 *:systat               *:*                    LISTEN        root       
tcp        0      0 *:printer              *:*                    LISTEN        root       
tcp        0      0 *:shell                *:*                    LISTEN        root       
tcp        0      0 *:login                *:*                    LISTEN        root       
tcp        0      0 *:exec                 *:*                    LISTEN        root       
udp        0      0 *:rplay                *:*                    
udp        0      0 *:netbios-ns           *:*                    
udp        0      0 *:sunrpc               *:*                    
udp        0      0 *:ntalk                *:*                    
udp        0      0 *:talk                 *:*                    
udp        0      0 *:syslog               *:*                    
raw        0      0 *:1                    *:*                    
Active UNIX domain sockets
Proto RefCnt Flags      Type            State           Inode Path
unix  1      [ ACC ]    SOCK_STREAM     LISTENING         417 /dev/log
unix  2      [ ]        SOCK_STREAM     CONNECTED         440 
unix  2      [ ]        SOCK_STREAM     UNCONNECTED       441 /dev/log
unix  2      [ ]        SOCK_STREAM     CONNECTED         499 
unix  2      [ ]        SOCK_STREAM     UNCONNECTED       500 /dev/log
unix  2      [ ]        SOCK_STREAM     CONNECTED         517 
unix  2      [ ]        SOCK_STREAM     UNCONNECTED       518 /dev/log
</pre>
Die erste Spalte enthält das Transportprotokoll. Die zweite und dritte Spalte sagen 
etwas über die Anzahl der Bytes in der Empfangs- bzw. Sende-Warteschlange aus. Die 
nächsten beiden Spalten geben lokale und ferne Adressen einer Verbindung an. Diese 
Adressen bestehen aus der Internet-Adresse und der Portnummer der Kommunikationspartner.
Ist der Rechner in der /etc/hosts bzw. der Dienst in der /etc/services eingetragen, so 
werden statt der Adressen Rechnername bzw. der Name des Services aus gegeben. Dies 
läßt sich durch den Aufruf von <tt>netstat -in</tt> verhindern. Handelt es sich
4611 um einen Eintrag für einen aktiven Server, so wird die lokale Adresse in der Form
"*.&lt;portnummer&gt;" und ferne Adressen in der Form "*.*" angegeben. Diese Art der
Ausgabe zeigt an, daß der entsprechende Dienst bereit ist. Bei TCP-Diensten zeigt
zusätzlich die letzte Spalte an, daß der Server auf LISTEN aesetzt ist. Kommt
für einen speziellen Dienst keine Verbindung zustande, obwohl andere Programme 
(z.B. ping) funktionieren. so kann man mittels <tt>netstat -a</tt> auf dem 
Zielsystem überprüfen, ob der Server dort aktiv ist. Nur dann kann eine entsprechende  
Verbindung überhaupt aufgebaut werden.
<p>

</p><h3>traceroute</h3>
Um festzustellen, welchen Weg die Datenpakete zu einem fernen Rechner 
nehmen und wie "gut" die Verbindung dorthin ist, kann man 'traceroute' 
einsetzen. Das Programm schickt UDP-Pakete mit unterschiedlicher "Lebensdauer" 
an einen unbenutzten Port und wertet so die Fehlermeldungen der einzelnen 
Router und Gateways aus. Dem Kommando wird wie bei Ping nur der Rechnername 
oder eine IP-Nummer als Parameter übergeben. Für jeden Gateway wird 
dann auf dem Bildschirm eine Zeile ausgegeben:<br>
<pre>Zähler Gateway-Name Gateway-IP-Nummer "round-trip"-Zeit (3 Werte)<br>
</pre>
Traceroute sendet jeweils drei Datenpakete. Wenn auf ein Paket keine 
Antwort erfolgt, wird ein Sternchen (*) ausgegeben. Ist ein Gateway 
nicht erreichbar, wird statt einer Zeitangabe '!N' (network unreachable) 
oder '!H' (host unreachable) ausgegeben. Man kann so feststellen, wo 
eine Verbindung unterbrochen ist, und auch, welchen Weg die Daten nehmen 
- wo also der Zielrechner in etwa steht. Bei grafischen Benutzerschnittstellen 
erfolgt die Parameterangabe über Dialogfelder und nicht in der Kommandozeile.
<pre>$ traceroute www.linux.org
traceroute to www.linux.org (198.182.196.56), 30 hops max, 40 byte packets
 1  space-gw2m (194.97.64.8)  2.758 ms  3.637 ms  2.491 ms
 2  Cisco-M-IV.Space.Net (195.30.0.123)  6.413 ms  4.118 ms  4.107 ms
 3  Cisco-M-Fe0-0.Space.Net (195.30.0.126)  4.826 ms  4.508 ms  5.53 ms
 4  Cisco-ECRC-H1-0.Space.Net (193.149.44.2)  5.977 ms  6.273 ms  20.832 ms
 5  munich-ebs2-s0-0-0.ebone.net (192.121.158.189)  14.415 ms  17.018 ms  8.575 ms
 6  newyork-ebs1-s5-0-0.ebone.net (195.158.224.21)  137.35 ms  139.103 ms  138.14 ms
 7  serial0-0-1.br1.nyc4.ALTER.NET (137.39.23.81)  137.132 ms  141.742 ms  141.207 ms
 8  134.ATM2-0.XR1.NYC4.ALTER.NET (146.188.177.178)  135.375 ms  128.12 ms  165.913 ms
 9  189.ATM3-0.TR1.EWR1.ALTER.NET (146.188.179.54)  141.83 ms  144.798 ms  362.469 ms
10  105.ATM4-0.TR1.DCA1.ALTER.NET (146.188.136.185)  145.321 ms  147.889 ms  152.43 ms
11  299.ATM6-0.XR1.TCO1.ALTER.NET (146.188.161.169)  354.577 ms  133.535 ms  348.647 ms
12  193.ATM8-0-0.GW2.TCO1.ALTER.NET (146.188.160.49)  152.444 ms  369.313 ms  150.106 ms
13  uu-peer.oc12-core.ai.net (205.134.160.2)  365.008 ms  509.81 ms  144.898 ms
14  border-ai.invlogic.com (205.134.175.254)  270.065 ms  341.586 ms  153.441 ms
15  router.invlogic.com (198.182.196.1)  356.496 ms  506.371 ms  532.983 ms
16  www.linux.org (198.182.196.56)  584.957 ms  300.612 ms  380.004 ms
</pre>
<p>

</p><h3>Netcat</h3>
Netcat ist das "Schweizer Taschenmesser" für Netzwerker. Es handelt sich um
ein einfaches Werkzeug, das Daten von einer Netzverbindung liest und auf die
Standardausgabe ausgibt oder Daten von der Standardeingabe auf eine Netzverbindung 
schreibt. Es ist also ein "Back-End"-Tool für andere Software. Das Programm
hat folgende Optionen:
<ul>
<li><tt>-g gateway</tt>: Source-Routing hop points (bis zu 8)
</li><li><tt>-G num</tt>: Source-Routing-Pointer: 4, 8, 12, ...
</li><li><tt>-h</tt>: Hilfe
</li><li><tt>-i secs</tt>: Delay-Intervall für gesendete Zeilen und gescannte Ports
</li><li><tt>-l</tt>: "Listen"-Modus
</li><li><tt>-n</tt>: Nur numerische IP-Adressen (kein DNS)
</li><li><tt>-o file</tt>: Hexdump des Netzverkehrs
</li><li><tt>-p port</tt>: lokale Portnummer (Einzelport oder Bereich (lo-hi))
</li><li><tt>-q secs</tt>: Wartezeit bis zum Programmende nach einen EOF
</li><li><tt>-b</tt>: UDP-Broadcasts erlauben
</li><li><tt>-r</tt>: Zufällige lokale und ferne Ports
</li><li><tt>-s addr</tt>: lokale Quelladresse
</li><li><tt>-t</tt>: Telnet-Negotiation freigeben
</li><li><tt>-u</tt>: UDP-Modus
</li><li><tt>-v</tt>: Geschwätzig (-vv, wenn das immer noch nicht reicht)
</li><li><tt>-w secs</tt>: Timeout für Verbindungsende
</li><li><tt>-z</tt>: Zero-I/O-Mode (für Scanning)
</li></ul>
Zum besseren Verständnis sollte man auf jeden Fall
<a href="https://web.archive.org/web/20070823185916fw_/http://www.netzmafia.de/skripten/server/netcat.html">die README-Datei</a> durchlesen.
<p>
Beispiel: Webserver abfragen:<br>
(Benutzereingaben fett)
</p><pre>echo -e 'GET / HTTP/1.0\n\n'  | netcat -w 10 www.ee.fhm.edu 80

HTTP/1.1 200 OK
Date: Wed, 15 Sep 2004 07:07:35 GMT
Server: Apache/1.3.28 (Linux/SuSE) mod_ssl/2.8.15 OpenSSL/0.9.7b PHP/4.3.3
X-Powered-By: PHP/4.3.3
Connection: close
Content-Type: text/html

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;
&lt;html&gt;

...

</pre>
netcat beendet sich erst, wenn die Verbindung abbricht. Der Parameter <tt>-w 10</tt>
bewirkt, daß spätestens 10 Sekunden nach dem Ende der Eingabe das Programm abbricht.
<p>
Mit <tt>netcat</tt> und <tt>inetd</tt> kann man lokale Ports an andere Hosts umleiten.
Die folgende Zeile in <tt>/etc/inetd.conf</tt> auf <i>sleepy</i> stellt den Port 80 
von <i>grumpy</i> lokal zur Verfügung:
</p><pre>80 stream tcp nowait nobody /usr/bin/nc /usr/bin/nc -w 3 grumpy 80
</pre>
beziehungsweise mit dem <tt>tcpd</tt>:
<pre>80 stream tcp nowait nobody /usr/sbin/tcpd /usr/bin/nc -w 3 grumpy 80
</pre>
<p>

</p><h4>Aufruf als Server</h4>
Durch den Aufruf
<pre>PROGRAM | nc -l -p PORT -w TIMEOUT
</pre>
oder
<pre>nc -l -p PORT -w TIMEOUT | PROGRAM
</pre>
<ol>
<li>erwartet <tt>netcat</tt> genau eine Verbindung auf Port <tt>PORT</tt>,
</li><li>verbindet <tt>netcat</tt> diese mit der Aus- oder Eingabe von <tt>PROGRAM</tt> und
</li><li>wartet maximal <tt>TIMEOUT</tt> Sekunden darauf, daß die Verbindung abgebrochen wird.
</li></ol>
Soll der Port bidirektional sein (Ein- und Ausgabe), lautet der Aufruf:
<pre>nc -l -p PORT -e PROGRAM
</pre>
Leider kann <tt>netcat</tt> keine Parameter an PROGRAM übergeben, daher wird 
man hier häufig ein Shellscript angeben.
<p>
Da <tt>netcat</tt> beim Ende der Verbindung beendet wird, kann es nur eine 
einzige Verbindung bedienen. 

</p><h4>Verzeichnisbäume über ein Internet kopieren</h4>
Mit Hilfe von von <tt>netcat</tt>, <tt>tar</tt> und <tt>bash</tt> kann man 
Verzeichnisbäume von einem Host auf einen anderen kopieren. Die
Dateien werden komprimiert und mit ihren Attributen (Zugriffsrechte/änderungsdatum) 
übertragen. Hierzu läßt man auf dem empfangenden Host <tt>netcat</tt> auf Port 4711 
lauschen und leitet seine Ausgabe in <tt>tar</tt> um:
<pre>$ nc -vlp 4711 | tar xvpf -
listening on [any] 4711 ...
</pre>
Auf der sendenden Seite ruft man eine Shellfunktion auf, welche die 
übergebenen Dateien und Verzeichnisse zusammentart und
an den Port 4711 des empfangenden Rechners sendet:
<pre>$ ( cd QUELLDIR ; tar cvpf - * | nc -w 1 ZIELHOST 4711 )
</pre>
<p>

</p><h3>Wget</h3>
Wget ist ein Download-Tool, das gleichermaßen mit WWW- wie FTP-Servern umgehen 
kann und dank zahlreicher Optionen genau die Dateien holt, die Sie brauchen.
Zugleich ist es aber auch ein nützliches Kommandozeilentool für
den Servermanager, um den Zugriff zu testen.
<p>
Auf HTTP und FTP aufsetzend kann man beispielsweise ganze Archive oder Homepages 
spiegeln. Auch mit einer schlechten Anbindung ans Internet
eignet sich das Programm hervorragend zum Download im Hintergrund: Nicht
nur ein "Anknüpfen" an eine abgebrochene übertragung, sondern auch ein
Update ist möglich -- Wget kann aufgrund von Timestamps erkennen, ob es
eine aktuelle Version einer Datei schon heruntergeladen hat. Zu finden ist es unter
<a href="https://web.archive.org/web/20070823185916/http://www.gnu.org/software/wget/wget.html">http://www.gnu.org/software/wget/wget.html</a>.
</p><p>
Der Standardaufruf von Wget ist <tt>wget [options] URL</tt>. 
Wget ist ein GNU-Tool, d. h. alle Parameter haben eine
lange (<tt>wget --version</tt>) und eine kurze Form (<tt>wget -V</tt>). Mit
<tt>wget -h</tt> (oder <tt>--help</tt>) bekommen Sie eine ausführliche
Kommandoübersicht. Ein erstes Beispiel:
</p><pre><b>wget http://www.netzmafia.de/</b>
--16:15:16--  http://www.netzmafia.de:80/
           =&gt; `index.html'
Connecting to www.netzmafia.de:80... connected!
HTTP request sent, awaiting response... 200 OK
Length: 8,208 [text/html]

    0K -&gt; ........                             [100%]

12:15:18 (9.01 KB/s) - `index.html' saved [8208/8208]
</pre> 
Auf den lokalen Computer wird die Datei <tt>index.html</tt> heruntergeladen. 
Bilder und Unterverzeichnisse sind nicht mit eingeschlossen. Möchten Sie eine 
Stufe tiefer gehen, probieren Sie die Option <tt>-r</tt> (für
<tt>--recursive</tt>). Jetzt folgt Wget den Links und der
Verzeichnisstruktur der zu spiegelnden Seiten. Wichtig ist in diesem
Zusammenhang der Parameter <tt>-l num</tt> (<tt>--level=num</tt>), bei dem
<tt>num</tt> die Anzahl der Level festlegt.<br>
Ein Aufruf der Form <tt>wget -r --level=1 http://www.netzmafia.de/</tt>
bewirkt etwa, daß die Unterverzeichnisse der ersten Ebene einbezogen werden.
Es wird dabei ein Verzeichnis <tt>www.netzmafia.de</tt> angelegt, in dem die
geladenen Unterverzeichnisse eingerichtet werden.
Als Standard-Level für die Rekursion ist 5 vorgegeben.
<p>
Ist ein Download unterbrochen worden, kann mit Hilfe des Parameters 
<tt>-c</tt> (<tt>--continue</tt>) der Ladevorgang wieder aufgenommen werden.
Um bestimmte Seiten in regelmäßigen Abständen immer wieder zu sichern, gibt es 
die Option <tt>-N</tt> (<tt>--timestamping</tt>): 
Es wird bei jeder Datei der Zeitstempel mit dem der lokalen Datei verglichen und
nur geladen, wenn die ferne Datei neuer ist als die lokale.
</p><p>
Mit dem Aufruf <tt>wget -nd</tt> (<tt>--no-directories</tt>) wird die
Verzeichnisstruktur der fernen Site nicht übernommen. Vorsicht ist hier
jedoch geboten bei Dateien mit gleichen Namen: sie werden einfach
überschrieben. Umgekehrt wird mit der Option <tt>-x</tt> 
(<tt>--force-directories</tt>) die Verzeichnisstruktur der fernen Site auf jeden
Fall komplett übernommen. Die Option <tt>-nH</tt> (<tt>--no-host-directories</tt>)
übernimmt die Verzeichnisstruktur vom Server, aber der Hostname wird nicht
mit berücksichtigt, es wird ins aktuelle Verzeichnis gespiegelt.
</p><p>
Wildcards sind unter Wget nicht möglich. Die Option <tt>-A "liste"</tt> 
(<tt>--accept</tt>) schafft Abhilfe. In der "liste" definieren Sie die 
zu ladenden Dateitypen, zum Beispiel:
</p><pre>wget -r -l1 -A jpg,gif,png http://www.netzmafia.de
</pre>
Danach finden sich im Verzeichnis nur noch diese Bilddateien und eine Datei 
<tt>index.html</tt>, die Wget braucht, um die Bilder zu finden. Hinter den
Kulissen saugt Wget eigentlich alle Dateien, entfernt dann aber nicht benötigte.
<pre>...
13:03:19 (8.73 KB/s) - `bla.html' saved [8584/8584]

Removing bla.html since it should be rejected.
...
</pre>

Mit <tt>-R liste</tt> (<tt>--reject</tt>) können Sie Dateierweiterungen
ausschlie^ßen. Der Aufruf <tt>wget -r -l1 -R doc,avi,mpg,mp3 
http://www.netzmafia.de</tt> würde die angegebenen Dateitypen aussparen. 
Ein Download-Limit können Sie darüber 
hinaus mit dem Parameter <tt>-Q</tt> (<tt>--quota</tt>) setzen. Die Begrenzung 
bezieht sich auf die Gesamtmenge der Daten und wird standardmä^ßig in Bytes
angegeben. Eine Begrenzung in Kilobytes oder Megabytes ist auch
möglich - dazu wird <tt>k</tt> oder <tt>m</tt> an die Zahl angehängt.
<p>
Fast alle Parameter, die Sie <tt>wget</tt> beim Start mitgegeben haben,
können Sie in eine Konfigurationsdatei  mit dem Namen <tt>.wgetrc</tt> 
im Heimatverzeichnis eintragen. Zum Beispiel:
</p><pre>tries = 20
reclevel = 8
timestamping = on
dirstruct = on
</pre>
<p>
Weitere Informationen liefert die <a href="https://web.archive.org/web/20070823185916fw_/http://www.netzmafia.de/skripten/server/wget.html">Wget-Beschreibung</a>.
</p><p>

<a name="2.5"></a>
</p><h2>2.5 Triviale Anfragen an höhere Protokolle</h2>
Auch auf den höheren Protokollebenen gibt es triviale Anfragen,
mit denen man untersuchen kann, ob ein Partner überhaupt antwortet.
Das Hauptwerkzeug ist hier das ganz normale Telnet-Programm, das für 
nahezu jede Platform verfügbar ist.
<p>
"<tt>echo</tt>" bezeichnet beispielsweise einen Service, nämlich TCP-Port 7,
der ankommende Meldungen schlicht zurückschickt (siehe unten).
Das kann man direkt mit <tt>telnet</tt> ausprobieren:
</p><pre>$ telnet localhost echo
Trying 127.0.0.1...
     Connected to localhost.
Escape character is '^]'.
hello world
hello world
^]

telnet&gt; quit
Connection closed.
</pre>
Auch eine Webserverabfrage mach kein Problem. Nach Aufbau der Telnet-Verbindung gibt 
man den gewünschten Dateipfad (genauer, ein Kommando des HTTP-Protokolls, im 
Beispiel unten "<tt>GET / HTTP/1.0</tt>") und anschliessend eine Leerzeile ein, z.B.:
<pre>telnet www.netzmafia.de 80
Trying 129.187.206.160...
Connected to www.netzmafia.de.
Escape character is '^]'.
GET / HTTP/1.0

HTTP/1.1 200 OK
Date: Wed, 15 Sep 2004 07:46:45 GMT
Server: Apache/1.3.26 (Unix) Debian GNU/Linux mod_ssl/2.8.9 OpenSSL/0.9.6c
Last-Modified: Wed, 12 May 2004 13:47:57 GMT
ETag: "1f7078-797-40a22b0d"
Accept-Ranges: bytes
Content-Length: 1943
Connection: close
Content-Type: text/html; charset=iso-8859-1

&lt;html&gt;

...

&lt;/html&gt;


Connection closed by foreign host.
</pre>
<p>

<a name="2.6"></a>
</p><h2>2.6 Einfache Protokolle</h2>
Die folgenden Protokoll eignen sich gut, um bei den ersten Versuchen mit
der Netzwerkprogrammierung die eigenen Programme zu testen (oder auch den unter
2.5. geschilderten Zugriff). Normalerweise sind die entsprechenden Ports gesperrt, 
man muss sie auf dem Zielrechner meist erst freigeben.

<h4>Das chargen-Protokol</h4>
<tt>Chargen</tt> ist ein auf Telnet basierendes Protokoll, das zu Testzwecken
Ascii-Zeichen auf den aufrufenden Port sendet. Der Service läuft über 
den TCP- bzw. UDP-Port 19. Sobald eine Verbindung aufgebaut ist, sendet der 
Server eine ASCII-Folge bzw. unter UDP ein Datagramm, in dem Zeichen eines 
Zeichengenerators enthalten sind. Alle weiteren eingehenden Daten werden vom 
Server nicht verarbeitet, die Verbindung muß vom aufrufenden Host geschlossen 
werden. Beispiel:
<pre>telnet 129.187.206.160 19 
Trying 129.187.206.160... 
Connected to 129.187.206.160.
Escape character is '^]'.
 !"#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefg
!"#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefgh
"#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghi
#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghij
$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijk
%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijkl
&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklm
'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmn
()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmno
)*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnop
*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopq
+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqr
,-./012   
^]

telnet&gt; quit
Connection closed.
</pre> 

Das chargen-Protokoll ist somit eine einfache Möglichkeit, Verbindungen 
und gegebenenfalls Terminal-Einstellungen zu überprüfen.     
Der Datenfluß  wird bei chargen-TCP-Verbindungen durch den normalen
TCP-Datenfluß-Kontrollmechanismus gesteuert, so daß Pakete nicht
schneller verschickt als empfangen werden können.
Dasselbe gilt für UDP, Datagramme werden nur verschickt, wenn die
Empfangsbestätigung des letzten Datagramms eingetroffen ist. 
<p>

</p><h4>Das echo-Protokoll</h4>
<tt>Echo</tt> ist ein auf Telnet basierendes Protokoll, das nichts weiter
tut, als die empfangenen Daten an den Erzeuger
zurückzuschicken. Dies läuft sowohl unter TCP als auch unter UDP
auf Port 7. Sobald der Server Daten unter TCP bzw. Datagramme unter
UDP empfängt, sendet er diese unverzüglich zurück.
Dies erfolgt solange, bis der anrufende Rechner die Verbindung
unterbricht. Beispiel:
<pre>telnet 129.187.206.160 7
Trying 129.187.206.160...
Connected to 129.187.206.160.
Escape character is '^]'.
Hallo
Hallo
^]

telnet&gt; quit
Connection closed.
</pre>
<p>
Mit dem <tt>echo-</tt>Protokoll lassen sich auf sehr einfache Weise
speziell Terminaleinstellungen testen, z.B. kann man so einen
Überblick über die verwendeten Codetables der eingesetzten
Terminals erlangen.
Dieser Dienst erzeugt ebenfalls wenig Datenverkehr, so daß sich die
Verbindung auch durch langsame Leitungen sehr gut testen läßt.
</p><p>

</p><h4>Das daytime-Protokoll</h4>
<tt>daytime</tt> ist ein auf Telnet basierendes Protokoll, das zur
Abfrage der Zeit und des Datums eines entfernt liegenden Rechners 
dient. Der Service läuft über den TCP- bzw. UDP-Port 13.
Sobald eine Verbindung aufgebaut ist, sendet der Server eine ASCII-Zeichenfolge 
bzw. unter UDP ein Datagramm, in dem das aktuelle Datum und die Zeit des 
angesprochenen Systems enthalten sind. Alle weiteren eingehenden Daten 
werden vom Server nicht verarbeitet, und die Verbindung wird nach dem Senden 
geschlossen. Beispiel:
<pre>telnet 129.187.206.160 13
Trying 129.187.206.160...
Connected to 129.187.206.160.
Escape character is '^]'.
Wed Sep 15 15:03:23 2004
Connection closed by foreign host.
</pre>
Das daytime-Protokoll ist somit eine einfache Möglichkeit, 
Verbindungen und die Systemzeit vernetzter Rechner zu überprüfen.
Beim Zeitabgleich ist die Zeit, die die Nachricht im Netz verbringt, zu
berücksichtigen. 
<p>


</p><center><table border="0" width="100%">
<tbody><tr>
<td align="LEFT" valign="BOTTOM"><img src="Internet-Technologie-Dateien/left.gif" border="0"> <a href="https://web.archive.org/web/20070823185916/http://www.netzmafia.de/skripten/perl/index.html">Zum vorhergehenden Abschnitt</a></td>
<td align="CENTER" valign="BOTTOM"><img src="Internet-Technologie-Dateien/up.gif" border="0"> <a href="https://web.archive.org/web/20070823185916fw_/http://www.netzmafia.de/skripten/server/index.html">Zum Inhaltsverzeichnis</a></td>
<td align="RIGHT" valign="BOTTOM"><img src="Internet-Technologie-Dateien/right.gif" border="0"> <a href="https://web.archive.org/web/20070823185916fw_/http://www.netzmafia.de/skripten/server/server3.html">Zum nächsten Abschnitt</a></td>
</tr></tbody></table></center>
<p></p><hr>
<h6><tt>Copyright © FH München, FB 04, Prof. Jürgen Plate</tt></h6>
<h6><i>Letzte Aktualisierung: 30. Oct 2004</i></h6>



</body></html>
<!--
     FILE ARCHIVED ON 18:59:16 Aug 23, 2007 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 05:24:05 May 28, 2025.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  captures_list: 0.719
  exclusion.robots: 0.027
  exclusion.robots.policy: 0.011
  esindex: 0.013
  cdx.remote: 39.608
  LoadShardBlock: 167.2 (3)
  PetaboxLoader3.datanode: 124.948 (4)
  PetaboxLoader3.resolve: 271.616 (2)
  load_resource: 293.493
-->