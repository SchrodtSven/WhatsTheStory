<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252"><script type="text/javascript" src="TCP_IP-Dateien/bundle-playback.js" charset="utf-8"></script>
<script type="text/javascript" src="TCP_IP-Dateien/wombat.js" charset="utf-8"></script>
<script>window.RufflePlayer=window.RufflePlayer||{};window.RufflePlayer.config={"autoplay":"on","unmuteOverlay":"hidden"};</script>
<script type="text/javascript" src="TCP_IP-Dateien/ruffle.js"></script>
<script type="text/javascript">
    __wm.init("https://web.archive.org/web");
  __wm.wombat("http://www.netzmafia.de/skripten/netze/netz8.html","20070611100850","https://web.archive.org/","web","https://web-static.archive.org/_static/",
	      "1181556530");
</script>
<link rel="stylesheet" type="text/css" href="TCP_IP-Dateien/banner-styles.css">
<link rel="stylesheet" type="text/css" href="TCP_IP-Dateien/iconochive.css">
<!-- End Wayback Rewrite JS Include -->

<title>Grundlagen Computernetze</title>
</head>
<body text="#000000" bgcolor="#FFFFFF" link="#0000FF" alink="#FF0000" vlink="#FF00FF">
<center><table border="0" width="90%">
<tbody><tr><td align="LEFT"><img src="TCP_IP-Dateien/eyes.gif"></td>
<td align="RIGHT"><h3>Grundlagen Computernetze</h3> 
<br><b><i>Prof. Jürgen Plate</i></b></td></tr>
</tbody></table></center>
<hr>

<a name="8.1"></a>
<h1 align="center">TCP/IP</h1>

Die Protokolle der TCP/IP-Familie wurden in den 70-er Jahren für den 
Datenaustausch in heterogenen Rechnernetzen (d. h. Rechner verschiedener 
Hersteller mit unterschiedlichen Betriebssystemen) entwickelt. TCP steht 
für 'Transmission Control Protocol' (Schicht 4) und IP für 'Internet 
Protocol' (Schicht 3).  Die Protokollspezifikationen sind in sogenannten 
RFC-Dokumenten (RFC - Request for Comment) festgeschrieben und veröffentlicht. 
Aufgrund ihrer Durchsetzung stellen sie Quasi-Standards dar.  
<p>
</p><center><img src="TCP_IP-Dateien/tcpipiso.gif"></center>
<p>
Die Schichten 5 - 7 des OSI-Standards werden hier in einer Anwendungsschicht 
zusammengefaßt, da die Anwendungsprogramme alle direkt mit der 
Transportschicht kommunizieren.
</p><p>
In Schicht 4 befindet sich außer TCP, welches gesicherten Datentransport 
(<b>verbindungsorientiert</b>, mit Flußkontrolle (d. h. 
Empfangsbestätigung, etc.)  durch Windowing ermöglicht, 
auch UDP (User Datagram Protocol), in welchem verbindungsloser und ungesicherter 
Transport festgelegt ist. Beide Protokolle erlauben durch die Einführung 
von sogenannten Ports den Zugriff mehrerer Anwendungsprogramme gleichzeitig 
auf ein- und dieselbe Maschine.
</p><p>
In Schicht 3 ist das <b>verbindungslose</b> Internet-Protokoll (IP) angesiedelt.
Datenpakete werden auf den Weg geschickt, ohne daß auf eine 
Empfangsbestätigung gewartet werden muß. IP-Pakete dürfen unter 
bestimmten Bedingungen (TTL=0, siehe unten) sogar vernichtet werden. 
In Schicht 3 werden damit auch die IP-Adressen festgelegt. Hier findet auch das Routing, 
das heißt die Wegsteuerung eines Paketes von einem Netz ins andere 
statt. Ebenfalls in diese Ebene integriert sind die ARP-Protokolle (ARP 
- Address Resolution Protocol), die zur Auflösung (= Umwandlung) einer 
logischen IP-Adresse in eine physikalische (z. B. Ethernet-) Adresse dienen 
und dazu sogenannte Broadcasts (Datenpakete, durch die alle angeschloßenen 
Stationen angesprochen werden) verwenden. ICMP, ein Protokoll, welches den 
Austausch von Kontroll- und Fehlerpaketen im Netz ermöglicht, ist ebenfalls 
in dieser Schicht realisiert. <br>
</p><p>
Die Schichten 1 und 2 sind gegenüber Schicht 3 protokolltransparent. 
 Sie können durch standardisierte Protokolle (z. B. Ethernet (CSMA/CD), 
FDDI, SLIP (Serial Line IP), PPP (Point-to-Point Protocol)) oder andere 
Übertragungsverfahren realisiert werden. 
</p><p>
</p><center><img src="TCP_IP-Dateien/tcpstac.gif"></center>
<p>
Zur TCP/IP-Familie gehören mehrere Dienstprogramme der höheren 
OSI-Schichten (5 - 7), z. B.: <br>
</p><ul>
<li>Telnet (RFC 854)<br>
Ein virtuelles Terminal-Protokoll, um vom eigenen Rechensystem einen interaktiven 
Zugang zu einem anderen System zu realisieren. <br>
</li><li>FTP (RFC 959)<br>
Dieses (File-Transfer-) Protokoll ermöglicht, die Dateidienste eines 
Fremdsystems interaktiv zu benutzen sowie die Dateien zwischen den Systemen 
hin und her zu kopieren. <br>
</li><li>NFS (RFC 1094)<br>
Das Network File System ermöglicht den Zugriff auf Dateien an einem 
entfernten System so, als wären sie auf dem eigenen.  Man nennt dies 
auch einen transparenten Dateizugriff.  NFS basiert auf den zur TCP/IP-Familie 
gehörenden UDP- (User- Datagramm-) Protokollen (ebenfalls Schicht 4), 
RFC 768. Im Unterschied zu TCP baut UDP keine gesicherten virtuellen Verbindungen 
zwischen kommunizierenden Hosts auf. Aufgrund dieser Eigenschaft ist es 
für den Einsatz in lokalen Netzen vorgesehen. <br>
</li><li>NNTP (RFC 977)<br>
Das Network News Transfer Protocol spezifiziert Verteilung, Abfrage, Wiederauffinden 
und das Absetzen von  News-Artikeln innerhalb eines Teils oder der gesamten 
Internet-Gemeinschaft. Die Artikel werden in regional zentralen Datenbasen 
gehalten. Einem Benutzer ist es möglich, aus dem gesamten Angebot nur 
einzelne Themen zu abonnieren. <br>
</li><li>SMTP (RFC 821/822)<br>
Das Simple-Mail-Transfer-Protokoll (RFC 821) ist ein auf der IP-Adressierung 
sowie auf der durch den RFC 822 festgelegten Namensstruktur basierendes 
Mail-Protokoll. <br>
</li><li>DNS (RFC 920)<br>
Der Domain Name Service unterstützt die Zuordnung von Netz- und Host-Adressen 
zu Rechnernamen. Dieser Service ist z. B. erforderlich für die Anwendung 
von SMTP sowie in zunehmendem Maße auch für Telnet und FTP.  
Aus Sicherheitsgründen wendet sich der fremde Host an den DNS, um zu 
prüfen, ob der IP-Adresse des ihn rufenden Rechners auch ein (Domain-)Name 
zugeordnet werden kann.  Falls nicht, wird der Verbindungsaufbau abgelehnt. 
</li></ul>
<p>

</p><h2><a name="8.1">Die TCP/IP-Protokolle</a></h2>
Der große Vorteil der TCP/IP-Protokollfamilie ist die einfache Realisierung 
von Netzwerkverbunden. Einzelne Lokale Netze werden über Router oder 
Gateways verbunden. Einzelne Hosts können daher über mehrere Teilnetze 
hinweg miteinander kommunizieren.<br>
IP als Protokoll der Ebene 3 ist die unterste Ebene, die darunter liegenden 
Netzebenen können sehr unterschiedlich sein:
<ul>
<li>LANs (Ethernet, Token-Ring, usw.)<br>
</li><li>WANs (X.25, usw.)<br>
</li><li>Punkt-zu-Punkt-Verbindungen (SLIP, PPP)<br>
</li></ul>
<p>
<table border="1" cellpadding="3">
<tbody><tr>
   <th colspan="9">Internet-Protokolle</th>
</tr><tr>
   <td align="center" colspan="2" width="16%"><small><i>OSI-Schicht</i></small></td>
   <td align="center" colspan="6" width="72%"><small><i>Internet Protokoll Suite</i></small></td>
   <td align="center" width="12%"><small><i>DOD Schicht</i></small></td>
</tr><tr>
   <td align="center" width="4%"><small>7</small></td>
   <td align="center" width="12%"><small>Anwendung</small></td>
   <td align="center" width="12%"><small>File Transfer</small></td>
   <td align="center" width="12%"><small>Electronic<br>Mail</small></td>
   <td align="center" width="12%"><small>Terminal Emulation</small></td>
   <td align="center" width="12%"><small>Usenet News</small></td>
   <td align="center" width="12%"><small>World Wide Web</small></td>
   <td align="center" width="12%"><small>Domain Name Service</small></td>
   <td align="center" width="12%"><small>Art der<br>Kommuni-<br>kation</small></td>
</tr><tr>
   <td align="center"><small>6</small></td>
   <td align="center"><small>Darstellung</small></td>
   <td align="center" rowspan="2"><small>File Transfer Protocol (FTP)<br>RFC 959</small></td>
   <td align="center" rowspan="2"><small>Simple Mail Transfer Protocol (SMTP)<br>RFC 821</small></td>
   <td align="center" rowspan="2"><small>Telnet Protocol (Telnet)<br>RFC 854</small></td>
   <td align="center" rowspan="2"><small>Usenet News Transfer Protocol (NNTP)<br>RFC 977</small></td>
   <td align="center" rowspan="2"><small>Hypertext Transfer Protocol (HTTP)<br>RFC 2616</small></td>
   <td align="center" rowspan="2"><small>Domain Name Service (DNS)<br>RFC 1034</small></td>
   <td align="center" rowspan="2"><small>Applikation</small></td>
</tr><tr>
   <td align="center"><small>5</small></td>
   <td align="center"><small>Sitzung</small></td>
</tr><tr>
   <td align="center"><small>4</small></td>
   <td align="center"><small>Transport</small></td>
   <td align="center" colspan="5"><small>Transmission Control Protocol (TCP)<br>RFC 793</small></td>
   <td align="center"><small>User Datagram Protocol (UDP)<br>RFC 768</small></td>
   <td align="center"><small>Host to Host Kommunikation</small></td>
</tr><tr>
   <td align="center"><small>3</small></td>
   <td align="center"><small>Netzwerk</small></td>
   <td align="center"><small>Address Resolution Protocol (ARP)<br>RFC 826</small></td>
   <td align="center" colspan="4"><small>Internet Protocol (IP)<br>RFC 791</small></td>
   <td align="center"><small>Internet Control Messsage Protocol<br>RFC 792</small></td>
   <td align="center"><small>Internet</small></td>
</tr><tr>
   <td align="center"><small>2</small></td>
   <td align="center"><small>Sicherung</small></td>
   <td align="center" colspan="2"><small>Ethernet</small></td>
   <td align="center"><small>Token Ring</small></td>
   <td align="center"><small>DQDB</small></td>
   <td align="center"><small>FDDI</small></td>
   <td align="center"><small>ATM</small></td>
   <td align="center"><small>lokales Netzwerk</small></td>
</tr><tr>
   <td align="center"><small>1</small></td>
   <td align="center"><small>Physikalische Übertragung</small></td>
   <td align="center"><small>Twisted Pair</small></td>
   <td align="center"><small>Lichtwellenleiter</small></td>
   <td align="center" colspan="2"><small>Coaxkabel</small></td>
   <td align="center"><small>Funk</small></td>
   <td align="center"><small>Laser</small></td>
   <td align="center"><small>Netzzugriff</small></td>
</tr></tbody></table>
</p><p>
Es ist offensichtlich, daß die Gateways neben dem Routing weitere 
nichttriviale Funktionen haben, wenn sie zwischen den unterschiedlichsten 
Teilnetzen vermitteln (z. B. unterschiedliche Protokolle auf Ebene 2, unterschiedliche 
Datenpaketgröße, usw.).<br>
</p><p>
Aus diesem Grund existieren in einem Internet drei unabhängige Namens- 
bzw. Adressierungsebenen:
</p><ul>
<li>Physikalische Adressen (z. B. Ethernet-Adresse)<br>
</li><li>Internet-Adressen (Internet-Nummer, IP-Adresse)<br>
</li><li>Domain-Namen<br>
</li></ul>
<p>
Die Ethernet-Adresse wurde bereits behandelt, auf die anderen beiden Ebenen 
wird in den folgenden Abschnitten eingegangen. Die Umsetzung der höchsten 
Ebene (Domain-Namen) in IP-Adressen erfolgt durch das oben erwähnte 
DNS, worauf die Dienstprogramme der Schichten 5-7 zurückgreifen.  
</p><p>

</p><h2><a name="8.2">ARP</a></h2>
Die Umsetzung einer IP-Adresse in eine Hardware-Adresse erfolgt durch
Tabellen und auf Hardware-Ebene (z. B. Ethernet) automatisch über 
ARP (Adress Resolution Protocol). Dazu ein Beispiel: 
<p>
Die Station A will Daten an eine Station B mit der Internetadresse I(B) 
senden, deren physikalische Adresse P(B) sie noch nicht kennt. Sie sendet 
einem ARP-Request an alle Stationen im Netz, der die eigene physikalische 
Adresse und die IP-Adresse von B enthält. 
</p><p>
</p><center><img src="TCP_IP-Dateien/arp1.gif"></center>
<p>
Alle Stationen erhalten und überprüfen den ARP-Request und die 
angesprochene Station B antwortet, indem sie einen ARP-Reply mit ihrer 
eigenen physikalischen Adresse an die Station A sendet. Letztere speichert 
die Zuordnung in einer Tabelle (Address Resolution Cache).
</p><p>
</p><center><img src="TCP_IP-Dateien/arp2.gif"></center>
<p>
Auch für die Umkehrfunktion gibt es eine standardisierte Vorgehensweise, 
den RARP (Reverse ARP). Hier sendet die Station A unter Angabe ihrer physikalischen 
Adresse P(A) einen RARP-Request. Wenn im Netz nur eine Station als RARP-Server 
eingerichtet ist (eine Station, die alle Zuordnungen von P(x) &lt;--&gt; 
I(x) "kennt"), antwortet diese mit einem RARP-Reply an die anfragende 
Station, der I(A) enthält. Diese Funktion ist z. B. für sogenannte 
"Diskless Workstations" wichtig, die ihre gesamte Software von 
einem Server laden.<br>
</p><p>
</p><center><img src="TCP_IP-Dateien/arp.gif" alt=""></center>
<p>

</p><h2><a name="8.3">IP - Internet Protocol</a></h2>
Auf der Netzwerkschicht aufbauend liegt die Internet-Schicht, die die erste 
Abstraktionsschicht vom Transportmechanismus darstellt. Auf dieser Schicht 3 stellt 
das Internet-Protokoll (IP) den grundlegenden Netzdienst zur Verfügung,
den Versand von Datenpaketen, sogenannten Datagrammen, über verschiedene Netze 
hinweg. Die Netzwerkschicht hat keine Information darüber, von welcher Art 
die Daten sind, die sie befördert. Nehmen wir als Beispiel das Ethernet: 
Von der Ethernet-Karte werden die vom Netz kommenden Daten an die Treibersoftware 
für die Karte weitergereicht. Diese interpretiert einen Teil dieser Daten als
IP-Header und den Rest als Datenteil eines IP-Paketes. Auf diese Weise ist der 
IP-Header innerhalb eines Ethernet-Paketes eingekapselt. Aber auch das IP-Paket 
selbst enthält wieder ein Datenpaket für eine höhere Protokollebene 
(TCP), dessen Header auf der IP-Ebene als Bestandteil der Daten erscheint. Man kann
sich das so vorstellen, wie die russischen Puppen, die ineinandergeschachtelt sind. 
Die kleinste Puppe ganz innen repräsentiert die Nutzdaten, alle außen herum
geschachtelten Puppen sind 'Protokoll-Verpackung'.
<p>
</p><center><img src="TCP_IP-Dateien/schichten.gif"></center>
<p>
IP ist ein <b>verbindungsloses Protokoll</b>. Es ist also nicht notwendig, eine 
IP-Verbindung zu einem Rechner zu 'öffnen', bevor man Daten zu diesem Rechner 
senden kann, sondern es genügt, das IP-Paket einfach abzusenden und darauf zu
vertrauen, daß es schon ankommen wird. Bei einem verbindungsorientierten 
Protokoll wird beim Öffnen einer Verbindung getestet, ob der Zielrechner 
überhaupt erreichbar ist. Ein verbindungsloses Protokoll macht das nicht und 
kann demnach auch nicht garantieren, daß ein Datenpaket überhaupt beim
Empfänger ankommt. IP garantiert auch nicht, daß von einem einmal 
abgeschickten Datenpaket nur eine Kopie beim Empfänger ankommt oder daß 
in einer bestimmten Reihenfolge abgeschickte Datenpakete auch wieder in dieser 
Reihenfolge empfangen werden.<br>
Normalerweise laufen die IP-Pakete über mehrere Zwischenstationen, bis sie 
am Zielrechner ankommen. Bricht irgendwann während der Übertragung ein 
Übertragungsweg zusammen, so wird ein neuer Weg zum Ziel gesucht und benutzt. 
Da der neue Weg zeitlich länger oder kürzer sein kann als der alte, kann
man keine allgemeingültigen Aussagen darüber machen, in welcher Reihenfolge 
IP-Pakete beim Empfänger eintreffen. Es kann auch sein, daß bei dieser 
Umschalterei IP-Pakete verlorengehen oder sich verdoppeln. Das Beheben der so 
entstehenden Probleme überläßt das IP-Protokoll anderen, 
höherliegenden Schichten.
</p><p>
Das Internet-Protokoll ist somit ein <b>verbindungsloser</b> Dienst  
mit einem 'Unreliable Datagram Service', d. h. es wird auf der IP-Ebene 
weder die Richtigkeit der der Daten noch die Einhaltung von Sequenz, Vollständigkeit 
und Eindeutigkeit der Datagramme überprüft. Ein zuverlässiger 
verbindungsorientierter Dienst wird in der darüberliegenden TCP-Ebene 
realisiert.
</p><p>
Ein IP-Datagramm besteht aus einem Header und einem nachfolgenden Datenblock, 
der seinerseits dann z. B. in einem Ethernet-Frame "verpackt" 
wird. Die maximale Datenlänge wird auf die maximale Rahmenlänge 
des physikalischen Netzes abgestimmt. Da nicht ausgeschlossen werden kann, 
daß ein Datagramm auf seinem Weg ein Teilnetz passieren muß, 
dessen Rahmenlänge niedriger ist, müssen zum Weitertransport mehrere 
(Teil-)Datagramme erzeugt werden. Dazu wird der Header im Wesentlichen repliziert 
und die Daten in kleinere Blöcke unterteilt. Jedes Teil-Datagramm hat 
also wieder einen Header. Diesen Vorgang nennt man Fragmentierung. Es handelt 
sich um eine rein netztechnische Maßnahme, von der Quell- und Zielknoten 
nichts wissen müssen. Es gibt natürlich auch eine umgekehrte Funktion, 
"Reassembly", die kleine Datagramme wieder zu einem größeren 
packt. Geht auf dem Übertragungsweg nur ein Fragment verloren, muß 
das gesamte Datagramm wiederholt werden. Es gilt die Empfehlung, daß 
Datagramme bis zu einer Länge von 576 Bytes unfragmentiert übertragen 
werden sollten.<br>
</p><p>

</p><h4>Format des IP-Headers</h4>
<p>
</p><center><img src="TCP_IP-Dateien/ip.gif" alt=""></center>
<p>
</p><dl>
<dt>Version
</dt><dd>Kennzeichnet die IP-Protokollversion

</dd><dt>IHL (Internet Header Length) 
</dt><dd>Die Angabe der Länge des IP-Headers erfolgt 
in 32-Bit-Worten (normalerweise 5). Da die Optionen nicht unbedingt auf 
Wortlänge enden, wird der Header gegebenenfalls aufgefüllt. 

</dd><dt>Type of Service
</dt><dd>Alle Bits haben nur "empfehlenden" Charakter. 'Precedence' bietet 
die Möglichkeit, Steuerinformationen vorrangig zu befördern.  

</dd><dt>Total Length
</dt><dd>Gesamtlänge des Datagramms in Bytes (max. 64 KByte).

</dd><dt>Identification
</dt><dd>Dieses und die beiden folgenden Felder steuern die Reassembly. Eindeutige 
Kennung eines Datagramms. Anhand dieses Feldes und der 'Source Address' 
ist die Zusammengehörigkeit von Fragmenten zu detektieren. 

</dd><dt>Flags
</dt><dd>Die beiden niederwertigen Bits haben folgende Bedeutung:
<ul>
<li>Don't fragment: Für Hosts, die keine Fragmentierung unterstützen 
</li><li>More fragments: Zum Erkennen, ob alle Fragmente eines Datagramms empfangen wurden
</li></ul>

</dd><dt>Fragment Offset
</dt><dd>Die Daten-Bytes eines Datagramms werden numeriert und auf die Fragmente 
verteilt. Das erst Fragment hat Offset 0, für alle weiteren erhöht 
sich der Wert um die Länge des Datenfeldes eines Fragments. Anhand 
dieses Wertes kann der Empfänger feststellen, ob Fragmente fehlen. 
Beispiel siehe unten.

</dd><dt>Time-to-live (TTL)
</dt><dd>Jedes Datagramm hat eine vorgegebene maximale Lebensdauer, die hier angegeben 
wird. Auch bei Routing-Fehlern (z. B. Schleifen) wird das Datagramm irgendwann 
aus dem Netz entfernt. Da Zeitmessung im Netz problematisch ist, und keine 
Startzeit im Header vermerkt ist, decrementiert jeder Gateway dieses Feld 
--&gt; de-facto ein 'Hop Count'.

</dd><dt>Protocol
</dt><dd>Da sich unterschiedliche Protokolle auf IP stützen, muß das übergeordnete 
Protokoll (ULP, Upper Layer Protocol) angegeben werden. Wichtige ULPs sind 
<ul>
<li>1:   ICMP Internet Control Message P.
</li><li>3:   GGP  Gateway-to-Gateway P.
</li><li>6:   TCP  Transmission Control P.
</li><li>8:   EGP  Exterior Gateway P.
</li><li>17:   UDP  User Datagram P.
</li></ul>

</dd><dt>Header Checksum
</dt><dd>16-Bit-Längsparität über den IP-Header (nicht die Daten) 

</dd><dt>Source Address
</dt><dd>Internet-Adresse der Quellstation

</dd><dt>Destinantion Address
</dt><dd>Internet-Adresse der Zielstation

</dd><dt>Options
</dt><dd>Optionales Feld für weitere Informationen (deshalb gibt es auch die 
Header-Länge). Viele Codes sind für zukünftige Erweiterungen 
vorgesehen. Die Optionen dienen vor allem der Netzsteuerung, der Fehlersuche 
und für Messungen. Die wichtigsten sind:
<ul>
<li>Record Route: Weg des Datagramms mitprotokollieren
</li><li>Loose Source Routing: Die sendende Station schreibt einige Zwischenstationen 
vor (aber nicht alle)
</li><li>Strict Source Routing: Die sendende Station schreibt alle Zwischenstationen 
vor.
</li><li>Timestamp Option: Statt seiner IP-Adresse (wie bei Record Route) trägt 
jeder Gateway den Bearbeitungszeitpunkt ein (Universal Time). 
</li></ul>

</dd><dt>Padding
</dt><dd>Füllbits
</dd></dl>
<p>
Die Hauptaufgabe von IP ist es also, die Unterschiede zwischen den verschiedenen, 
darunterliegenden Netzwerkschichten zu verbergen und eine einheitliche Sicht auf die
verschiedensten Netztechniken zu präsentieren. So gibt es IP nicht nur in Netzen, 
sondern auch als SLIP (Serial Line IP) oder PPP (Point to Point Protocol) für 
Modem- oder ISDN-Verbindungen. Zur Vereinheitlichung gehören auch die 
Einführung eines einheitlichen Adressierungsschemas und eines
Fragmentierungsmechanismus, der es ermöglicht, große
Datenpakete durch Netze mit kleiner maximaler Paketgröße
zu senden: Normalerweise existiert bei allen Netzwerken eine maximale
Größe für ein Datenpaket. Im IP-Jargon nennt man
diese Grenze die 'Maximum Transmisson Unit' (MTU). Natürlich ist
diese Obergrenze je nach verwendeter Hardware bzw. Übertragungstechnik 
unterschiedlich. Die Internet-Schicht teilt IP-Pakete, die größer 
als die MTU des verwendeten Netzwerks sind, in kleinere Stücke, 
sogenannte Fragmente, auf. Der Zielrechner setzt diese Fragmente dann wieder zu 
vollständigen IP-Paketen zusammen, bevor er sie an die darüberliegenden 
Schichten weitergibt. Der Fragement Offset gibt an, an welcher Stelle in Bezug auf 
den IP-Datagramm-Anfang das Paket in das Datagramm einzuordnen ist. Aufgrund des 
Offset werden die Pakete in die richtige Reihenfolge gebracht. Dazu ein Beispiel:
</p><p>
Es soll ein <b>TCP</b>-Paket mit einer Länge von 250 Byte über 
<b>IP</b> versandt werden. Es wird angenommen, daß ein IP-Header eine Länge von 
20 Byte hat und eine maximale Länge von 128 Byte pro Paket nicht überschritten 
werden darf Der Identifikator des Datagramms beträgt 43 und der Fragmentabstand wird 
in 8-Byte-Schritten gezählt. Das Datenfragment muß also durch 8 dividierbar
sein.
</p><p>
</p><center><img src="TCP_IP-Dateien/fragment.gif"></center>
<p>
Da alle Fragmente demselben Datagramm angehören, wird der Identifikator für alle 
Fragmente beibehalten. Im ersten Fragment ist das Fragment Offset natürlich noch 
Null, das MF-Bit jedoch auf 1 gesetzt, um zu zeigen, daß noch Fragmente
folgen. Im IP-Header des zweiten Fragments beträgt das Fragment Offset 13 
(104/8 = 13) und zeigt die Position des Fragments im Datagramm an. Das MF-Bit ist 
noch immer 1, da noch ein Datenpaket folgt. Der Header des dritten Fragments 
enthält dann ein MF-Bit mit dem Wert 0, denn es handelt sich um das letzte 
Datenpaket zum Datagramm 43. Das Fragment Offset ist auf 26 gesetzt, da vorher schon 
208 Daten-Bytes (8 * 26 = 208) übertragen wurden.<br>
Sobald das erste Fragment (gleich welches) im Empfänger ankommt, 
wird ein Timer gesetzt. Sind innerhalb der dort gesetzten Zeit nicht alle Pakete zu einem
Datagramm eingetroffen, wird angenommen, daß Fragmente verlorengingen. Der
Empfänger verwirft dann alle Datenpakete mit diesem Identifikator.
</p><p>
Was geschieht aber, wenn der Kommunikationspartner nicht erreichbar ist? Wie schon 
erwähnt, durchläuft ein Datagramm mehrere Stationen. Diese Stationen sind in
der Regel Router oder Rechner, die gleichzeitig als Router arbeiten. Ohne 
Gegenmaßnahme würde das Datenpaket für alle Zeiten durch das Netze 
der Netze irren. Dazu gibt es im IP-Header neben anderer Verwaltungsinfo auch ein 
Feld mit dem Namen TTL (Time To Live). Der Wert von TTL kann zwischen 0 und 255 
liegen. Jeder Router, der das Datagramm transportiert, vermindert den Wert dieses
Feldes um 1. Ist der Wert von TTL bei Null angelangt, wird das Datagramm vernichtet.
</p><p>
Die Adressen, die im Internet verwendet werden, bestehen aus einer 32 Bit langen Zahl. 
Damit sich die Zahl leichter darstellen läßt, unterteilt man sie in 4 Bytes 
(zu je 8 Bit). Diese Bytes werden dezimal notiert und durch Punkte getrennt (a.b.c.d).
Zum Beispiel:
</p><pre>    141.84.101.2
    129.187.10.25
</pre>
Bei dieser Adresse werden zwei Teile unterscheiden, die Netzwerkadresse und die 
Rechneradresse, wobei unterschiedlich viele Bytes für beide Adressen verwendet
werden:<br>
Die Bereiche für die Netzwerkadresse ergeben sich durch die Zuordnung der
ersten Bits der ersten Zahl (a), die eine Erkennung der Netz-Klassen
möglich machen.
<p>
</p><h4>Netzklassen</h4>
<p>
</p><center><img src="TCP_IP-Dateien/netzklassen.gif"></center>
<p>
<table align="CENTER" width="80%" border="1" cellpadding="4">
<tbody><tr><td valign="TOP">&nbsp;</td>
<td valign="TOP"><b>Klasse A</b> - Netz</td>
<td valign="TOP"><b>Klasse B</b> - Netz</td>
<td valign="TOP"><b>Klasse C</b> - Netz</td>
</tr>
<tr><td valign="TOP">Netz-ID</td>
<td valign="TOP">8 Bit = 1 Byte</td>
<td valign="TOP">16 Bit = 2 Byte</td>
<td valign="TOP">24 Bit = 3 Byte</td>
</tr>
<tr><td valign="TOP">Host-ID</td>
<td valign="TOP">24 Bit = 3 Byte</td>
<td valign="TOP">16 Bit = 2 Byte</td>
<td valign="TOP">8 Bit = 1 Byte</td>
</tr>
<tr><td valign="TOP">Netzmaske</td>
<td valign="TOP">255.0.0.0</td>
<td valign="TOP">255.255.0.0</td>
<td valign="TOP">255.255.255.0</td>
</tr>
<tr><td valign="TOP">Adressklassen-ID<br>
(= Feste Bits im 1. Byte, 1. Quad)</td>
<td valign="TOP">0</td>
<td valign="TOP">10</td>
<td valign="TOP">110</td>
</tr>
<tr><td valign="TOP">Wertebereich (theoretisch)</td>
<td valign="TOP">0.0.0.0 bis 127.255.255.255</td>
<td valign="TOP">128.0.0.0 bis 191.255.255.255</td>
<td valign="TOP">192.0.0.0 bis 223.255.255.255</td>
</tr>
<tr><td valign="TOP">Anzahl der Netze</td>
<td valign="TOP">128 (= 2<b><sup>7</sup></b>)</td>
<td valign="TOP">16384 (= 2<b><sup>6</sup></b>*256 <br>= 64*256)</td>
<td valign="TOP">2097152 (= 2<b><sup>5</sup></b>*256*256 <br>= 32*256*256)</td>
</tr>
<tr><td valign="TOP">Anzahl der Rechner <br>im Netz</td>
<td valign="TOP">16777216 (= 256<b><sup>3</sup></b>)</td>
<td valign="TOP">65536 (= 256<b><sup>2</sup></b>)</td>
<td valign="TOP">256 (= 256<b><sup>1</sup></b>)</td>
</tr>
</tbody></table>
</p><p>

</p><h4>Besondere Adreßklassen</h4>
<p>
<table align="CENTER" width="80%" border="1" cellpadding="4">
<tbody><tr><td valign="TOP">&nbsp;</td>
<td valign="TOP"><b>Klasse D</b></td>
<td valign="TOP"><b>Klasse E</b></td>
</tr>
<tr><td valign="TOP">Adressklassen-ID</td>
<td valign="TOP">4 Bit = "1110"</td>
<td valign="TOP">5 Bit = "11110"</td>
</tr>
<tr><td valign="TOP">keine Netz-ID, sondern:</td>
<td valign="TOP">28 Bit-Identifikator</td>
<td valign="TOP">27 Bit-Identifikator</td>
</tr>
<tr><td valign="TOP">Wertebereich</td>
<td valign="TOP">224.0.0.0 bis 239.255.255.255</td>
<td valign="TOP">240.0.0.0 bis 247.255.255.255</td>
</tr>
<tr><td valign="TOP">Anwendungen</td>
<td valign="TOP">für Multicast-Gruppen</td>
<td valign="TOP">reservierte Adressen für Zukünftiges</td>
</tr>
</tbody></table>
</p><p>
Grundsätzlich gilt:
</p><ul>
<li>Alle Rechner mit der gleichen Netzwerkadresse gehören zu einem 
Netz und sind untereinander erreichbar. 
</li><li>Zur Koppelung von Netzen unterschiedlicher Adresse wird eine spezielle Hardware-
oder Softwarekomponente, ein sogenannter Router, benötigt.
</li><li>Je nach Zahl der zu koppelnden Rechner wird die Netzwerkklasse gewählt.
</li></ul>
In einem Netz der Klasse C können z. B. 254 verschiedene Rechner gekoppelt 
werden (Rechneradresse 1 bis 254). Die Hostadresse 0 wird für die Identifikation 
des Netzes benötigt und die Adresse 255 für Broadcast-(Rundruf-)Meldungen.
<p>
</p><center><img src="TCP_IP-Dateien/aufteilung.gif"></center>
<p>
Die Netzwerkadresse 127.0.0.1 bezeichnet jeweils den lokalen Rechner (loopback address). 
Sie dient der Konsistenz der Netzwerksoftware (jeder Rechner ist über
seine Adresse ansprechbar) und dem Test.
</p><p>
Damit man nun lokale Netze ohne Internetanbindung mit TCP/IP betreiben kann, ohne 
IP-Nummern beantragen zu müssen und um auch einzelne Rechnerverbindungen 
testen zu können, gibt es einen ausgesuchten Nummernkreis, der von keinem
Router nach außen gegeben wird. Diese "privaten" Adressen sind im RFC 1597
festgelegt. Es gibt ein Class-A-Netz, 16 Class-B-Netze und 255 Class-C-Netze:
</p><ul>
<li>Class-A-Netz: 10.0.0.0 - 10.255.255.255
</li><li>Class-B-Netze: 172.16.0.0 - 172.31.255.255
</li><li>Class-C-Netze: 192.168.0.0 - 192.168.255.255
</li></ul>
Zusätzlich hat die IANA auch das folgende Class-B-Netz für private
Netze reserviert, das schon von Apple- und Microsoft-Clients verwendet wird, sofern
kein DHCP-Server zur Verfügung steht. Das Verfahren heißt APIPA (Automatic Private IP Addressing):
<ul>
<li>169.254.0.0 - 169.254.255.255
</li></ul>
<p>
Der für IP reservierte Adressraum reicht nicht mehr aus, um alle 
Endgeräte anzusteuern. Mögliche Abhilfen:
</p><ul>
<li>Dynamische Vergabe von IP-Adressen: Dieses Verfahren wird beim Dial-In beim 
Provider verwendet. Es eignet sich auch im lokalen Netz, wenn davon auszugehen ist,
daß immer nur ein Teil der Rechner in Betrieb ist. Der Benutzer bekommt für 
die Dauer einer Verbindung eine IP-Adresse zugeteilt. Das bekannteste Verfahren 
heißt DHCP (dynamic host configuration protocol).
</li><li>Weiterentwicklung des IP-Protokolls: Mit IP Version 6 wird ein auf 128 Bit 
erweiterter Adressraum geschaffen. Damit stehen genügend Adressen zur Vefügung.
</li><li>Network Address Translation (NAT): Über ein Gateway wird im Internet
eine andere IP-Adresse verwendet als im lokalen Netz (private Adressräume).
Die Umsetzung erlaubt sogar, ein komplettes privates Netz (siehe oben) mit einer
einzigen externen IP-Adresse zu betreiben.
</li></ul>
<p>

</p><h3>Network Address Translation (NAT) und IP-Masquerading</h3>
Die begrenzte Verfügbarkeit von IP-Adressen hat dazu geführt, daß 
man sich Gedanken über verschiedene Möglichkeiten machen mußte, 
wie man mit den existierenden Adressen ein größeres Umfeld abdecken 
kann.
Eine Möglichkeit, um private Netze (und dazu gehört letztendlich auch 
ein privater Anschluß mit mehr als einem PC) unter Verwendung möglichst 
weniger Adressen an das Internet anzukoppeln stellen <b>NAT</b>, <b>PAT</b> 
und <b>IP Masquerading</b>. Alle Verfahren bilden private Adressen gemäß 
RFC 1918 oder einen proprietären (nicht registrierten) Adreßraum eines 
Netzes auf öffentliche registrierte IP-Adressen ab.
<ul>
<li>NAT (Network Address Translation)<br>
Beim NAT (Network Address Translation) werden die Adressen eines privaten Netzes 
über Tabellen öffentlich registrierten IP-Adressen zugeordnet. Der 
Vorteil besteht darin, daß Rechner, die in einem privaten Netz miteinander
kommunizieren, keine öffentlichen IP-Adressen benötigen.
IP-Adressen interner Rechner, die eine Kommunikation mit Zielen im Internet aufbauen, 
erhalten in dem Router, der zwischen dem Internet Service Provider (ISP) und dem 
privaten Netzwerk steht, einen Tabelleneintrag. Durch diese Eins-zu-Eins-Zuordnung
sind diese Rechner nicht nur in der Lage, eine Verbindung zu Zielen im Internet 
aufzubauen, sondern sie sind auch aus dem Internet erreichbar. Die interne Struktur 
des Firmennetzwerkes bleibt jedoch nach außen verborgen.
<p>
</p><center><img src="TCP_IP-Dateien/nat.gif"></center>
<p>

</p></li><li>IP Masquerading<br>
IP Masquerading, das manchmal auch als PAT (Port and Address Translation) bezeichnet 
wird, bildet <b>alle</b> Adressen eines privaten Netzwerkes auf <b>eine</b> einzelne 
öffentliche IP-Adresse ab. Dies geschieht dadurch, daß bei einer existierenden 
Verbindung zusätzlich zu den Adressen auch die Portnummern ausgetauscht werden. 
Auf diese Weise benötigt ein gesamtes privates Netz nur eine einzige registrierte 
öffentliche IP-Adresse.
Der Nachteil dieser Lösung besteht darin, daß die Rechner im privaten Netzwerk 
<b>nicht</b> aus dem Internet angewählt werden können. Diese Methode eignet 
sich daher hervorragend, um zwei und mehr Rechner eines privaten Anschlusses per 
DFÜ-Netzwerk oder ISDN-Router an das Internet zu koppeln.
<p>
</p><center><img src="TCP_IP-Dateien/pat.gif"></center>
<p>
IP Masquerading rückt mit dieser Funktionalität sehr nahe an Proxy- und 
Firewall-Lösungen heran, wobei ein Proxy explizit für ein Protokoll 
(z. B. HTTP) existieren und aufgerufen werden muß.
</p></li></ul>
<p>

</p><h3>Subnetze</h3>
Nachdem nun klar ist, was ein Netz der Klasse A oder B ist, soll auf die Bildung
von Subnetzen hingewiesen werden. Diese dienen dazu, ein bestehendes Netz
in weitere, kleinere Netze zu unterteilen. 
<ul>
<li>Subnetze sind Strukturierungsmöglichkeit für Netze, ohne 
daß man zusätzliche Klasse-A-, Klasse-B- oder Klasse-C-IP-Adressen braucht.
</li><li>Die Standardprozedur, um ein Netz in Unternetze (Subnetze) zu teilen,
nennt man "Subnetting".
</li><li>Die Hostadresse des A-, B- oder C-Netzes teilt sich in die Bereiche 
Subnetzadresse (Subnet-ID, Teilnetz-ID) und Hostadresse (verbleibende, verkürzte 
Host-ID). Ein Teil des Hostadressbereiches wird also genutzt, um die Subnetze zu 
unterscheiden.
</li><li>Die Netzadresse und den Subnetzanteil des Hostadressraumes bezeichnet man als 
"erweiterte Netzadresse" (extended network prefix).
</li><li>Die interne Subnetz-Struktur von A-, B- oder C-Netzen ist nach außen hin 
unsichtbar.
</li><li>Damit Router in der Lage sind, Datagramme in das richtige Netz zuzustellen, 
müssen sie bei der IP-Adresse den Netz- und Hostanteil unterscheiden können.
</li><li>Dies geschieht traditionell durch die Netzmaske bzw. Subnetzmaske (subnet mask).
</li></ul>

Die Subnetzmaske dient dem Rechner dazu, die Zuordnung von Netzwerk-Teil und 
Host-Teil vorzunehmen. Sie hat denselben Aufbau wie eine IP-Adresse (32 Bit bzw. 
4 Byte). Per Definition sind alle Bit des "Netzwerk-Teils" auf 1 zu setzen, 
alle Bit des "Host-Teils" auf 0. Für die o.a. Adreßklassen hat die 
Subnetzmaske demnach folgendes Aussehen:
<p>
<table align="CENTER" width="80%" border="1" cellpadding="4">
<tbody><tr> 
<th>Adreß-Klasse
</th><th>Subnetzmaske (binär)
</th><th>Subnetzmaske (dezimal)
</th></tr>
<tr> 
<td>Class A</td>
<td><tt>11111111.00000000.00000000.00000000</tt></td>
<td><tt>255.0.0.0</tt></td>
</tr>
<tr> 
<td>Class B</td>
<td><tt>11111111.11111111.00000000.00000000</tt></td>
<td><tt>255.255.0.0</tt></td>
</tr>
<tr> 
<td>Class C</td>
<td><tt>11111111.11111111.11111111.00000000</tt></td>
<td><tt>255.255.255.0</tt></td>
</tr>
</tbody></table>
<br>
Diese Subnetzmaske (auch "Default Subnetzmaske" genannt) kann manuell 
überschrieben werden. 
</p><p>
Eine Subnet-Maske für ein Netz der Klasse 
C lautet daher 255.255.255.0. Das bedeutet, daß die ersten drei Bytes die 
Netzadresse angeben und das vierte Byte die Rechner adressiert. Eine Subnetz-Maske 
mit dem Wert 255.255.0.0 würde folglich ein Netz der Klasse B angeben und
für ein C-Netz steht die Maske 255.255.255.0. 

</p><h4>Aufteilung in Subnetze </h4>
<p>
<table align="CENTER" width="80%" border="1" cellpadding="4">
<tbody><tr><td valign="TOP">Netzwerk-<br>anteil in Bit</td>
<td valign="TOP">Hostanteil<br>in Bit</td>
<td valign="TOP">Subnetz-<br>anzahl *)</td>
<td valign="TOP">Hostanzahl **)</td>
<td valign="TOP">Subnetzmaske</td>
</tr>
<tr><td valign="TOP"><b>8</b></td>
<td valign="TOP"><b>24</b></td>
<td valign="TOP"><b>1</b></td>
<td valign="TOP"><b>16777216</b></td>
<td valign="TOP"><b>255.0.0.0 &nbsp; &nbsp; &nbsp; Klasse A</b></td>
</tr>
<tr><td valign="TOP">9</td>
<td valign="TOP">23</td>
<td valign="TOP">2</td>
<td valign="TOP">128*65536</td>
<td valign="TOP">255.<b>128</b>.0.0</td>
</tr>
<tr><td valign="TOP">10</td>
<td valign="TOP">22</td>
<td valign="TOP">4</td>
<td valign="TOP">64*65536</td>
<td valign="TOP">255.<b>192</b>.0.0</td>
</tr>
<tr><td valign="TOP">11</td>
<td valign="TOP">21</td>
<td valign="TOP">
8</td>
<td valign="TOP">32*65536</td>
<td valign="TOP">255.<b>224</b>.0.0</td>
</tr>
<tr><td valign="TOP">12</td>
<td valign="TOP">20</td>
<td valign="TOP">16</td>
<td valign="TOP">16*65536</td>
<td valign="TOP">255.<b>240</b>.0.0</td>
</tr>
<tr><td valign="TOP">13</td>
<td valign="TOP">19</td>
<td valign="TOP">32</td>
<td valign="TOP">8*65536</td>
<td valign="TOP">255.<b>248</b>.0.0</td>
</tr>
<tr><td valign="TOP">14</td>
<td valign="TOP">18</td>
<td valign="TOP">64</td>
<td valign="TOP">4*65536</td>
<td valign="TOP">255.<b>252</b>.0.0</td>
</tr>
<tr><td valign="TOP">15</td>
<td valign="TOP">17</td>
<td valign="TOP">128</td>
<td valign="TOP">2*65536</td>
<td valign="TOP">255.<b>254</b>.0.0</td>
</tr>
<tr><td valign="TOP"><b>16</b></td>
<td valign="TOP"><b>16</b></td>
<td valign="TOP"><b>1</b></td>
<td valign="TOP"><b>65536</b></td>
<td valign="TOP"><b>255.255.0.0 &nbsp; &nbsp; &nbsp; Klasse B</b></td>
</tr>
<tr><td valign="TOP">17</td>
<td valign="TOP">15</td>
<td valign="TOP">2</td>
<td valign="TOP">128*256</td>
<td valign="TOP">255.255.<b>128</b>.0</td>
</tr>
<tr><td valign="TOP">18</td>
<td valign="TOP">14</td>
<td valign="TOP">4</td>
<td valign="TOP">64*256</td>
<td valign="TOP">255.255.<b>192</b>.0</td>
</tr>
<tr><td valign="TOP">19</td>
<td valign="TOP">13</td>
<td valign="TOP">8</td>
<td valign="TOP">32*256</td>
<td valign="TOP">255.255.<b>224</b>.0</td>
</tr>
<tr><td valign="TOP">20</td>
<td valign="TOP">12</td>
<td valign="TOP">16</td>
<td valign="TOP">16*256</td>
<td valign="TOP">255.255.<b>240</b>.0</td>
</tr>
<tr><td valign="TOP">21</td>
<td valign="TOP">11</td>
<td valign="TOP">32</td>
<td valign="TOP">8*256</td>
<td valign="TOP">255.255.<b>248</b>.0</td>
</tr>
<tr><td valign="TOP">22</td>
<td valign="TOP">10</td>
<td valign="TOP">64</td>
<td valign="TOP">4*256</td>
<td valign="TOP">255.255.<b>252</b>.0</td>
</tr>
<tr><td valign="TOP">23</td>
<td valign="TOP">9</td>
<td valign="TOP">128</td>
<td valign="TOP">2*256</td>
<td valign="TOP">255.255.<b>254</b>.0</td>
</tr>
<tr><td valign="TOP"><b>24</b></td>
<td valign="TOP"><b>8</b></td>
<td valign="TOP"><b>1</b></td>
<td valign="TOP"><b>256</b></td>
<td valign="TOP"><b>255.255.255.0 &nbsp; &nbsp; &nbsp; Klasse C</b></td>
</tr>
<tr><td valign="TOP">25</td>
<td valign="TOP">7</td>
<td valign="TOP">2</td>
<td valign="TOP">128</td>
<td valign="TOP">255.255.255.<b>128</b></td>
</tr>
<tr><td valign="TOP">26</td>
<td valign="TOP">6</td>
<td valign="TOP">4</td>
<td valign="TOP">64</td>
<td valign="TOP">255.255.255.<b>192</b></td>
</tr>
<tr><td valign="TOP">27</td>
<td valign="TOP">5</td>
<td valign="TOP">8</td>
<td valign="TOP">32</td>
<td valign="TOP">255.255.255.<b>224</b></td>
</tr>
<tr><td valign="TOP">28</td>
<td valign="TOP">4</td>
<td valign="TOP">16</td>
<td valign="TOP">16</td>
<td valign="TOP">255.255.255.<b>240</b></td>
</tr>
<tr><td valign="TOP">29</td>
<td valign="TOP">3</td>
<td valign="TOP">32</td>
<td valign="TOP">8</td>
<td valign="TOP">255.255.255.<b>248</b></td>
</tr>
<tr><td valign="TOP">30</td>
<td valign="TOP">2</td>
<td valign="TOP">64</td>
<td valign="TOP">4</td>
<td valign="TOP">255.255.255.<b>252</b></td>
</tr>
</tbody></table>
</p><p>
</p><h4>Anmerkungen:</h4>
<ul>
<b>*)&nbsp;</b> Die erste und letzte bei der Unterteilung entstehenden Adressen 
dürfen nicht verwendet werden (Verwechslung mit Netz- und Broadcast-Adresse 
des übergeordneten Netzes). Die Anzahl der Subnetze verringert sich somit 
jeweils um zwei:<br>
Ist der Netzwerkanteil der IP-Adresse <b>n</b> Bits, dann erhält man
<b>(2<sup>n</sup>) - 2</b> Subnetze.
<p>
<b>**)</b> Die Rechneranzahl verringert sich ebenfalls um zwei wegen Subnetz-Adresse 
(alle Rechnerbits auf 0) und Broadcast-Adresse (alle Rechnerbits auf 1):<br>
Ist der Hostanteil der IP-Adresse <b>m</b> Bits, dann erhält man
<b>(2<sup>m</sup>) - 2</b> Hosts pro Subnetz.
</p></ul>
<p>
Besitzt breispielsweise ein Unternehmen ein Netz der Klasse C, möchte 
man dieses vielleicht in zwei Segmente unterteilen, die voneinander getrennt sind. 
Der Broadcastverkehr des ersten Segments kann so das andere nicht beeinträchtigen. 
In diesem Fall kommt die Subnetz-Maske zum Einsatz, welche die Rechneradressen in 
zwei Bereiche gliedert. Sollen die Rechner in vier gleich große Subnetze mit 
je 64 Knoten eingeteilt werden, lautet die Subnetz-Maske 255.255.255.192. Es
gilt die folgende Formel für das <i>Maskier-Byte:</i>
</p><p>
Bytewert = 256 - (Anzahl der Knoten in einem Segment)
</p><p>
Als das Subnetting erstmals standardisiert wurde, war es verboten die Subnetze zu 
nutzen, in denen alle Subnetzbits den Wert 0 oder 1 hatten (siehe Anmerkungen oben).
Damit ergeben sich im Beispiel nur zwei Subnetze mit je 62 Hosts. Inzwischen beherrschen
fast alle Systeme korrektes Subnetting ("classless" routing).
</p><p>
</p><h4>Beispiel: Aufteilung in 4 Subnetze</h4>
Ein Netz der Klasse C soll in vier gleich große Subnetze geteilt werden. Die 
Netzadresse beträgt 192.168.98.0. Der Administrator wählt daher zur 
Unterteilung die Subnetz-Maske 255.255.255.192. Die vier Rechner mit den IP-Adressen 
192.168.98.3, 192.168.98.73. 192.168.98.156 und 192.168.98.197 befinden sich daher 
in vier Subnetzen zwischen denen geroutet werden muß. Broadcasts in Subnetz 1 
werden somit nicht in die anderen Subnetze übertragen. Es ist nun zum Beispiel 
für das Unternehmen möglich, die Rechner des Vertriebs in Subnetz 1, die 
des Einkaufs in Subnetz 2, jene der Entwicklung in Subnetz 3 und ein Netz aus 
Demorechnern in Subnetz 4 zu organisieren. Damit ist gesichert, daß 
Störungen in einzelnen Subnetzen auch lokal auf diese beschränkt 
bleiben. Sie schlagen nicht auf die Datenstruktur des ganzen Unternehmens durch.
<p>
</p><center><img src="TCP_IP-Dateien/subnetting.gif"></center>
<p>
Allgemein ergibt sich für ein C-Netz folgende Aufstellung:
</p><p>
</p><h4>Subnetze eines C-Netzes</h4>
In Klammern die reduzierte Anzahl der Subnetze (Anzahl - 2). Die rot unterlegten
Möglichkeiten sind dann in der Praxis nicht einsetzbar.
<p>
<table align="CENTER" width="80%" border="1" cellpadding="4">
  <tbody><tr>
    <td align="center">Subnetzbits</td>
    <td align="center">Hostbits</td>
    <td align="center">mögliche Subnetze</td>
    <td align="center">Hostadressen</td>
    <td align="center">Subnetzmaske</td>
  </tr>
  <tr>
    <td align="center"><font color="#CC0000">1</font></td>
    <td align="center"><font color="#CC0000">7</font></td>
    <td align="center"><font color="#CC0000">2 (0)</font></td>
    <td align="center"><font color="#CC0000">126 (0)</font></td>
    <td align="center"><font color="#CC0000">255.255.255.128</font></td>
  </tr>
  <tr>
    <td align="center">2</td>
    <td align="center">6</td>
    <td align="center">4 (2)</td>
    <td align="center">62</td>
    <td align="center">255.255.255.192</td>
  </tr>
  <tr>
    <td align="center">3</td>
    <td align="center">5</td>
    <td align="center">8 (6)</td>
    <td align="center">30</td>
    <td align="center">255.255.255.224</td>
  </tr>
  <tr>
    <td align="center">4</td>
    <td align="center">4</td>
    <td align="center">16 (14)</td>
    <td align="center">14</td>
    <td align="center">255.255.255.240</td>
  </tr>
  <tr>
    <td align="center">5</td>
    <td align="center">3</td>
    <td align="center">32 (30)</td>
    <td align="center">6</td>
    <td align="center">255.255.255.248</td>
  </tr>
  <tr>
    <td align="center">6</td>
    <td align="center">2</td>
    <td align="center">64 (62)</td>
    <td align="center">2</td>
    <td align="center">255.255.255.252</td>
  </tr>
  <tr>
    <td align="center"><font color="#CC0000">7</font></td>
    <td align="center"><font color="#CC0000">1</font></td>
    <td align="center"><font color="#CC0000">128</font></td>
    <td align="center"><font color="#CC0000">0</font></td>
    <td align="center"><font color="#CC0000">255.255.255.254</font></td>
  </tr>
</tbody></table>
</p><p>

</p><h4>Beispiel: Aufteilung in 8 (6) Subnetze</h4>
Von den acht variabel verwendbaren Bits nutzt er also die drei höchstwertigen 
Bits für das Subnetz und die fünf letzten Bits für die Hostadresse.
Die erste Adresse jedes Subnetz ist die Adresse in der alle Hostbits den Wert 0 haben. 
<p>
<table align="CENTER" width="80%" border="1" cellpadding="4">
  <tbody><tr>
    <td>&nbsp;</td>
    <td colspan="3">Subnetzbits</td>
    <td colspan="5">Hostbits</td>
    <td>dezimal</td>
  </tr>
  <tr>
    <td>Dezimale Wertigkeit des Bit</td>
    <td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td><td>&nbsp;</td>
  </tr>
  <tr>
    <td><font color="#cc0000">erstes Subnetz</font></td>
    <td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td>
  </tr>
  <tr>
    <td>zweites Subnetz</td>
    <td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>32</td>
  </tr>
  <tr>
    <td>drittes Subnetz</td>
    <td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>64</td>
  </tr>
  <tr>
    <td>viertes Subnetz</td>
    <td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>96</td>
  </tr>
  <tr>
    <td>fünftes Subnetz</td>
    <td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>128</td>
  </tr>
  <tr>
    <td>sechstes Subnetz</td>
    <td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>160</td>
  </tr>
  <tr>
    <td>siebtes Subnetz</td>
    <td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>192</td>
  </tr>
  <tr>
    <td><font color="#cc0000">achtes Subnetz</font></td>
    <td><font color="#cc0000">1</font></td><td><font color="#cc0000">1</font></td><td><font color="#cc0000">1</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">224</font></td>
  </tr>
</tbody></table>
</p><p>Damit sind die acht zur Verfügung stehenden Subnetze bekannt:<br>
</p><pre><font color="#cc0000">192.168.0.0/27</font>
192.168.0.32/27
192.168.0.64/27
192.168.0.96/27
192.168.0.128/27
192.168.0.160/27
192.168.0.192/27
<font color="#cc0000">192.168.0.224/27</font>
</pre>
<h4>Anmerkung:</h4> 
<ul>
Die Zahl hinter dem Schrägstrich (oben ist das die 27) gibt an, 
wieviele Bits der 32 Bit langen IP-Adresse als Netzanteil verwendet werden.
</ul>
<p>
Diese Subnetze können jetzt einzelnen Netzen zugeordnet werden. Die folgende Tabelle 
zeigt die Netz- und Broadcastadressen von jedem einzelnen Subnetz und die Rechneradressen.
</p><p>
<table align="CENTER" width="80%" border="1" cellpadding="4">
  <tbody><tr>
    <td>Subnetz</td>
    <td colspan="3">IP-Adressen (letztes Oktett)</td>
  </tr>
  <tr>
    <td>&nbsp;</td><td>Netz</td><td>Hosts</td><td>Broadcast</td>
  </tr>
  <tr>
    <td><font color="#cc0000">erstes Subnetz</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">1-30</font></td><td><font color="#cc0000">31</font></td>
  </tr>
  <tr>
    <td>zweites Subnetz</td><td>32</td><td>33-62</td><td>63</td>
  </tr>
  <tr>
    <td>drittes Subnetz</td><td>64</td><td>65-94</td><td>95</td>
  </tr>
  <tr>
    <td>viertes Subnetz</td><td>96</td><td>97-126</td><td>127</td>
  </tr>
  <tr>
    <td>fünftes Subnetz</td><td>128</td><td>129-158</td><td>159</td>
  </tr>
  <tr>
    <td>sechstes Subnetz</td><td>160</td><td>161-190</td><td>191</td>
  </tr>
  <tr>
    <td>siebtes Subnetz</td><td>192</td><td>193-222</td><td>223</td>
  </tr>
  <tr>
    <td><font color="#cc0000">achtes Subnetz</font></td><td><font color="#cc0000">224</font></td><td><font color="#cc0000">225-254</font></td><td><font color="#cc0000">255</font></td>
  </tr>
</tbody></table>
</p><p>
Als kleine Hilfe gibt es hier noch einen Subnetz-Rechner 
als Javascript-Programm. Eingegeben wird eine IP-Netzadresse 
in CIDR-Form (<b>C</b>lassless <b>I</b>nter-<b>D</b>omain <b>R</b>outing, 
z.B. 10.1.2.0/24). Nach dem Klick auf "Berechnen" erscheinen 
im unteren Feld die Werte der Netzadresse, der Subnet-Maske und 
der Bereich der zugehörigen IP-Adressen, wobei die erste Adresse 
des angebenen Bereichs die Netzadresse darstellt und die letzte Adresse 
die Broadcast-Adresse.

</p><p>
</p><div align="CENTER">
<form name="CIDR">
<table bgcolor="#000000" border="0" cellpadding="1" cellspacing="0">
<tbody><tr><td>
 <table bgcolor="#DDDDDD" border="0" cellpadding="5" cellspacing="0">
 <tbody><tr>
 <td bgcolor="#DDDDDD">CIDR: </td>
 <td><input name="Eingabe" size="20" value="192.168.1.0/24">
     <input type="button" value="Berechnen" onclick="CalcSubnet()">
 </td><td>
 </td></tr><tr>
 <td bgcolor="#DDDDDD">IP-Bereich: </td>
 <td><textarea cols="40" rows="3" name="Result" onfocus="blur()"></textarea></td>
 </tr>
 </tbody></table>
</td></tr></tbody></table>
</form>

<script type="text/javascript">
// IP-Bereiche umrechnen
function CalcSubnet()
  { 
  document.CIDR.Result.value;
  Eingabe = document.CIDR.Eingabe.value;
  if (Eingabe != "")
    { 
    Wert = Eingabe.split("/");
    if (Wert.length != 2) 
      { 
      alert("Eingabe: IP-Adresse/Netzanteil\nz.B. 192.168.233.0/24"); 
      return; 
      }
    else
      { 
      IP = Wert[0].split(".");
      if (IP.length != 4) 
        { 
        alert("Fehlerhafte Eingabe der IP-Nummer! \nEine IP-Adresse besteht aus 4 Zahlen (0=< Zahl <=255), getrennt durch Punkte\nz.B. 192.168.233.0"); 
        return; 
        }
      }   
    }
  NETZ = "";
  LAST = "";
  MASK = "";
  NetNum = parseInt(Wert[1]);
  if (isNaN(NetNum)) 
    { 
    alert("Fehlerhafter Netzanteil!\nKeine Zahl!"); 
    return; 
    }
  if (NetNum < 0 || NetNum > 32) 
    { 
    alert("Netzanteil /" + NetNum +" ist nicht erlaubt (0=< Netzanteil =<32)"); 
    return; 
    }
  for (i=0; i<4; i++)
    { 
    if (CalcPart(IP[i])) 
      { 
      alert("Fehlerhafte Eingabe der IP-Nummer '" + IP[i] +"' im "+ (i+1) +". Byte!  \nEine IP-Adresse besteht aus 4 Zahlen (0=< Zahl <=255), getrennt durch Punkte\nz.B. 192.168.233.0"); 
      return; 
      }
    if (i < 3) 
      { NETZ += "."; LAST += "."; MASK += "." };
    }
  document.CIDR.Result.value = "Netz:  " + NETZ + "\nMaske: " + MASK + "\nRange: " + NETZ + " - " + LAST;
  }

function CalcPart(Part)
  { 
  if (isNaN(Part)) return 1;
  var m = parseInt(Part); 
  if (isNaN(m)) return 1;
  if(m < 0 || m > 255) return 1;
  var cumm =+ m; 
  if (NetNum >= 8) 
    { NETZ += cumm; LAST += cumm; MASK += "255"; }
  else
    { 
    if (NetNum < 0) 
      { NETZ += "0"; LAST += "255"; MASK += "0"; }
    else
      { 
      var f = 256, ZifNet = 0, ZifLast = 0, ZifMask = 0;
      while (f > 1)
        { 
        f = f/2; 
        NetNum -= 1;
        if (NetNum >= 0) 
          {
          if (m >= f) 
            { m -= f; ZifNet += f; ZifLast += f; }
          ZifMask += f;
          }
        else
          { 
          if (m > f) { m -= f; }
          ZifLast += f;
          } 
        }
      NETZ += ''+ZifNet; LAST += ''+ZifLast; MASK += ''+ZifMask;
      }
    }
  NetNum -= 8; 
  return 0;
  }
// --></script>
</div>
<p>

</p><h2><a name="8.4">ICMP - Internet Control Message Protocol</a></h2>
ICMP erlaubt den Austauch von Fehlermeldungen und Kontrollnachrichten auf 
IP-Ebene. ICMP benutzt das IP wie ein ULP, ist aber integraler Bestandteil 
der IP-Implementierung. Es macht IP nicht zu einem 'Reliable Service', ist 
aber die einzige Möglichkeit Hosts und Gateways über den Zustand 
des Netzes zu informieren (z. B. wenn ein Host temporär nicht erreichbar 
ist --&gt; Timeout).
<p>
Die ICMP-Nachricht ist im Datenteil des IP-Datagramms untergebracht, sie 
enthält ggf. den IP-Header und die ersten 64 Bytes des die Nachricht 
auslösenden Datagramms (z. B. bei Timeout).
</p><p>
</p><center><img src="TCP_IP-Dateien/icmp.gif" alt=""></center>
<p>
Die fünf Felder der ICMP-Message haben folgende Bedeutung: 
</p><dl>
<dt>Type
</dt><dd>Identifiziert die ICMP-Nachricht
<ul>
<li> 0   Echo reply
</li><li> 3   Destination unreachable
</li><li> 4   Source quench  
</li><li> 5   Redirect (Change a Route)
</li><li> 8   Echo request
</li><li>11   Time exceeded for a datagram
</li><li>12   Parameter Problem on a datagram
</li><li>13   Timestamp request
</li><li>14   Timestamp reply
</li><li>15   Information request
</li><li>16   Information reply
</li><li>17   Address mask request
</li><li>18   Address mask reply
</li></ul>
</dd><dt>Code
</dt><dd>Detailinformation zum Nachrichten-Typ

</dd><dt>Checksum  
</dt><dd>Prüfsumme der ICMP-Nachricht (Datenteil des IP-Datagramms) 

</dd><dt>Identifier und Sequence-Nummer 
</dt><dd>dienen der Zuordnung eintreffender Antworten 
zu den jeweiligen Anfragen, da eine Station mehrere Anfragen aussenden kann 
oder auf eine Anfrage mehrere Antworten eintreffen können. 
</dd></dl>
<p>
Wenden wir uns nun den einzelnen Nachrichtentypen zu:
</p><dl>
<dt>Echo request/reply
</dt><dd>Überprüfen der Erreichbarkeit eines Zielknotens. Es können 
Testdaten mitgeschickt werden, die dann unverändert zurückgeschickt 
werden (--&gt; Ping-Kommando unter UNIX).

</dd><dt>Destination unreachable
</dt><dd>Im Codefeld wird die Ursache näher beschrieben:
     0    Network unreachable
     1    Host unreachable
     2    Protocol unreachable
     3    Port unreachable
     4    Fragmentation needed
     5    Source route failed

</dd><dt>Source quench
</dt><dd>Wenn mehr Datagramme kommen als eine Station verarbeiten kann, sendet sie 
diese Nachricht an die sendende Station.

</dd><dt>Redirect
</dt><dd>wird vom ersten Gateway an Hosts im gleichen Teilnetz gesendet, wenn es 
eine bessere Route-Verbindung über einen anderen Gateway gibt. In der 
Nachricht wird die IP-Adresse des anderen Gateways angegeben. 

</dd><dt>Time exceeded
</dt><dd>Für diese Nachricht an den Quellknoten gibt es zwei Ursachen: 
<ul>
<li>Time-to-live exceeded (Code 0): Wenn ein Gateway ein Datagramm eliminiert, 
dessen TTL-Zähler abgelaufen ist.
</li><li>Fragment reassembly time exceeded (Code 1): Wenn ein Timer abläuft, 
bevor alle Fragmente des Datagramms eingetroffen sind.
</li></ul>
</dd><dt>Parameter problem on a Datagramm
</dt><dd>Probleme bei der Interpretation des IP-Headers. Es wird ein Verweis 
auf die Fehlerstelle und der fragliche IP-Header zurückgeschickt. 

</dd><dt>Timestamp request/reply
</dt><dd>Erlaubt Zeitmessungen und -synchronisation im Netz. Drei Zeiten werden gesendet 
(in ms seit Mitternacht, Universal Time):
<ul>
<li>Originate T.:  Sendezeitpunkt des Requests (vom Absender)
</li><li>Receive T.:    Ankunftszeit (beim Empfänger)
</li><li>Transmit T.:   Sendezeitpunkt des Reply (vom Empfänger) 
</li></ul>

</dd><dt>Information request/reply
</dt><dd>Mit dieser Nachricht kann ein Host die Netid seines Netzes erfragen, indem 
er seine Netid auf Null setzt.

</dd><dt>Address mask request/reply
</dt><dd>Bei Subnetting (siehe unten) kann ein Host die Subnet-Mask erfragen.  
</dd></dl>
<p>
Für den User nutzbar ist ICMP vor allem für die Kommandos <i>ping</i>
und <i>traceroute</i> (bei Windows "tracert"). Diese Kommandos senden ICMP-Echo-Requests
aus und warten auf den ICMP-Echo-Reply. So kann man die Erreichbarkeit eines
Knotens feststellen. Will man alle Knoten im lokalen Netz erkennen genügt ein
<i>ping</i> auf die Broadcast-Adresse, z. B.:
</p><pre>ping 192.168.33.255
</pre>
Zum Anzeigen der Arp-Tabelle gibt es unter Windows wie unter Linux das <i>arp</i>-Kommando,
mit <i>arp -a</i> erhält man eine Liste der aktuell gespeicherten MAC-Adressen und
deren Zuordnung zu IP-Adressen.
<p>
Führt man das obige <i>ping</i>-Kommando und das <i>arp</i>-Kommando nacheinander
aus, erhält man eine liste der IP- umd MAC-Adressen der aktiven lokalen Knoten, z.B.:
</p><pre>ping -b -c1 192.168.33.255
arp -a
</pre>
<p>


</p><h2><a name="8.5">UDP - User Datagram Protocol</a></h2>
UDP ist ein einfaches Schicht-4-Protokoll, das einen nicht zuverlässigen, 
verbindungslosen Transportdienst ohne Flußkontrolle zur Verfügung 
stellt. UDP ermöglicht zwischen zwei Stationen mehrere unabhängige 
Kommunikationsbeziehungen (Multiplex-Verbindung): Die Identifikation der 
beiden Prozesse einer Kommuninkationsbeziehung geschieht (wie auch bei TCP, 
siehe unten) durch Port-Nummern (kurz "Ports"), die allgemein 
bekannten Anwendungen fest zugeordnet sind. Es lassen sich aber auch Ports 
dynamisch vergeben oder bei einer Anwendung durch verschiedene Ports deren 
Verhalten steuern. Die Transporteinheiten werden 'UDP-Datagramme' oder 'User 
Datagramme' genannt. Sie haben folgenden Aufbau:
<p>
</p><center><img src="TCP_IP-Dateien/udp.gif" alt=""></center>
<p>
</p><dl>
<dt>Source Port
</dt><dd>Identifiziert den sendenden Prozeß (falls nicht benötigt, wird 
der Wert auf Null gesetzt).

</dd><dt>Destination Port
</dt><dd>Identifiziert den Prozeß des Zielknotens.

</dd><dt>Length
</dt><dd>Länge des UDP-Datagramms in Bytes (mindestens 8 = Headerlänge) 

</dd><dt>UDP-Checksum
</dt><dd>Optionale Angabe (falls nicht verwendet auf Null gesetzt) einer Prüfsumme. 
Zu deren Ermittlung wird dem UDP-Datagramm ein Pseudoheader von 12 Byte 
vorangestellt (aber nicht mit übertragen), der u. a. IP-Source-Address, 
IP-Destination-Address und Protokoll-Nummer (UDP = 17) enthält. 
</dd></dl>
<p>

</p><h2><a name="8.6">TCP - Transmission Control Protocol</a></h2>
Welches übergeordnete Protokoll der Transportschicht das Datenpaket 
erhält, steht im 'Protokoll'-Feld eines jeden IP-Paketes. Jedes Protokoll 
der Transportschicht bekommt eine eindeutige Identifikationsnummer zugewiesen, 
anhand der die IP-Schicht entscheiden kann, wie weiter mit dem Paket zu verfahren 
ist. Eines der wichtigsten Protokolle der Transportschicht ist TCP.
<p>
Die Aufgabe von TCP ist es, die oben geschilderten Defizite von IP zu verbergen. 
Für den TCP-Benutzer soll es nicht mehr sichtbar sein, daß die 
darunterliegenden Protokollschichten Datenpakete versenden, sondern es soll der
Benutzer mit einem Byte-Strom wie bei einer normalen Datei (oder einem Terminal) 
arbeiten können. TCP garantiert vor allen Dingen den korrekten Transport der 
Daten - jedes Paket kommt nur einmal, fehlerfrei und in der richtigen Reihenfolge an. 
Zusätzlich können bei TCP mehrere Programme die Verbindung zwischen
zwei Rechnern quasi-gleichzeitig nutzen. TCP teilt die Verbindung in viele 
virtuelle Kanäle ("Ports") auf, die zeitmultiplex mit Daten versorgt werden. 
Nur so ist es möglich, daß beispielsweise mehrere Benutzer eines
Rechners zur selben Zeit das Netz in Anspruch nehmen können oder daß man
mit einer einzigen Wählverbindung zum Provider gleichzeitig E-Mail empfangen und
Dateien per FTP übertragen kann.
</p><p>
Dieses Protokoll implementiert also einen verbindungsorientierten, sicheren Transportdienst 
als Schicht-4-Protokoll. Die Sicherheit wird durch positive Rückmeldungen 
(acknowledgements) und Wiederholung fehlerhafter Blöcke erreicht. Fast 
alle Standardanwendungen vieler Betriebssysteme nutzen TCP und das darunterliegende 
IP als Transportprotokoll, weshalb man die gesamte Protokollfamilie allgemein 
unter 'TCP/IP' zusammenfaßt. TCP läßt sich in lokalen und 
weltweiten Netzen einsetzen, da IP und die darunterliegenden Schichten mit 
den unterschiedlichsten Netzwerk- und Übertragungssystemen arbeiten 
können (Ethernet, Funk, serielle Leitungen, ...). Zur Realisierung 
der Flußkontrolle wird ein Fenstermechanismus (sliding windows)
verwendet (variable Fenstergröße). TCP-Verbindungen sind 
vollduplex. Wie bei allen verbindungsorientierten Diensten muß zunächst 
eine virtuelle Verbindung aufgebaut und bei Beendigung der Kommunikation 
wieder abgebaut werden. "Verbindungsaufbau" bedeutet hier eine 
Vereinbarung beider Stationen über die Modalitäten der Übertragung 
(z. B. Fenstergröße, Akzeptieren eines bestimmten Dienstes, usw.). 
Ausgangs- und Endpunkte einer virtuellen Verbindung werden wie bei UDP durch 
Ports identifiziert. Allgemein verfügbare Dienste
werden über 'well known' Ports (--&gt; feste zugeordnete Portnummer) 
erreichbar. Andere Portnummern werden beim Verbindungsaufbau vereinbart. 
</p><p>

Damit die ständige Bestätigung jedes Datensegments den Transport nicht 
über Gebühr hemmt, werden zwei Tricks verwendet. Zum einen kann die 
Empfangsbetätigung einem Segment in Gegenrichtung mitgegeben werden - das spart ein
separates Quittungssegment. Zweitens muß nicht jedes Byte sofort bestätigt 
werden, sondern es gibt ein sogenanntes 'Fenster'.
Die Fenstergröße gibt an, wieviele Bytes gesendet werden dürfen, 
bis die Übertragung quittiert werden muß. Erfolgt keine Quittung, 
werden die Daten nochmals gesendet. Die empfangene Quittung enthält 
die Nummer des Bytess, das als nächstes vom Empfänger erwartet 
wird - womit auch alle vorhergehenden Bytes quittiert sind. Die Fenstergröße 
kann dynamisch mit der Quittung des Empfängers geändert 
werden. Werden die Ressourcen knapp, wird die Fenstergröße verringert. 
Beim Extremfall Null wird die Übertragung unterbrochen, bis der Empfänger 
erneut quittiert. Neben einem verläßlichen Datentransport ist 
so auch die Flußkontrolle gewährleistet. 
</p><p>
</p><center><img src="TCP_IP-Dateien/windows.gif" alt=""></center>
<p>
Das Prinzip des Fenstermechanismus ist eigentlich ganz einfach. Wenn man das Bild
betrachtet, ergibt sich folgende Sachverhalt:
</p><ul>
<li> Die Fenster größe im Beispiel beträgt drei Bytes.
</li><li>Byte 1 wurde von der Datenquelle gesendet und vom Empfänger quittiert.
</li><li>Die Quelle hat die Bytes 2, 3 und 4 gesendet, sie wurden aber vom 
Empfänger noch nicht quittiert (Quittung eventuell noch unterwegs).
</li><li>Byte 5 wurde von der Quelle noch nicht gesendet. Er geht erst dann auf
die Reise, wenn die Quittung für Byte 2 (oder höher) eingetroffen ist.
</li></ul>
<p>
Das TCP-Paket wird oft auch als 'Segment' bezeichnet. Jedem TCP-Block ist ein 
Header vorangestellt, der aber wesentlich umfangreicher als die bisherigen ist:
</p><p>
</p><center><img src="TCP_IP-Dateien/tcp.gif" alt=""></center>
<p>
</p><dl>
<dt>Source Port
</dt><dd>Identifiziert den sendenden Prozeß. 

</dd><dt>Destination Port
</dt><dd>Identifiziert den Prozeß des Zielknotens.

</dd><dt>Sequence Number
</dt><dd>TCP betrachtet die zu übertragenden Daten als numerierten Bytestrom, 
wobei die Nummer des ersten Bytes beim Verbindungsaufbau festgelegt wird. 
Dieser Bytestrom wird bei der Übertragung in Blöcke (TCP-Segmente) 
aufgeteilt. Die 'Sequence Number' ist die Nummer des ersten Datenbytes im 
jeweiligen Segment (--&gt; richtige Reihenfolge über verschiedene Verbindungen 
eintreffender Segmente wiederherstellbar).

</dd><dt>Acknowledgement Number
</dt><dd>Hiermit werden Daten von der Empfängerstation bestätigt, wobei 
gleichzeitig Daten in Gegenrichtung gesendet werden. Die Bestätigung 
wird also den Daten "aufgesattelt" (Piggyback). Die Nummer bezieht 
sich auf eine Sequence-Nummer der empfangenen Daten; alle Daten bis zu dieser 
Nummer (ausschließlich) sind damit bestätigt --&gt; Nummer des 
nächsten erwarteten Bytes. Die Gültigkeit der Nummer wird durch 
das ACK-Feld (--&gt; Code) bestätigt.

</dd><dt>Data Offset
</dt><dd>Da der Segment-Header ähnlich dem IP-Header Optionen enthalten kann, 
wird hier die Länge des Headers in 32-Bit-Worten angegeben. 

</dd><dt>Res.
</dt><dd>Reserviert für spätere Nutzung

</dd><dt>Code
</dt><dd>Angabe der Funktion des Segments:
<ul>
<li>URG  Urgent-Pointer (siehe unten)
</li><li>ACK  Quittungs-Segment (Acknowledgement-Nummer gültig) 
</li><li>PSH  Auf Senderseite sofortiges Senden der Daten (bevor Sendepuffer 
gefüllt ist) und auf Empfangsseite sofortige Weitergabe an die Applikation 
(bevor Empfangspuffer gefüllt ist) z. B. für interaktive Programme. 
</li><li>RST  Reset, Verbindung abbauen
</li><li>SYN Das 'Sequence Number'-Feld enthält die initiale Byte-Nummer 
(ISN) --&gt; Numerierung  beginnt  mit ISN + 1. In der Bestätigung 
übergibt die Zielstation ihre ISN (Verbindungsaufbau).
</li><li>FIN Verbindung abbauen (Sender hat alle Daten gesendet), sobald der 
Empfänger alles korrekt empfangen hat und selbst keine Daten mehr loswerden 
will.
</li></ul>

</dd><dt>Window
</dt><dd>Spezifiziert die Fenstergröße, die der Empfänger bereit 
ist anzunehmen - kann dynamisch geändert werden.

</dd><dt>Checksum
</dt><dd>16-Bit Längsparität über Header und Daten.

</dd><dt>Urgent Pointer
</dt><dd>Markierung eines Teils des Datenteils als dringend. Dieser wird unabhängig 
von der Reihenfolge im Datenstrom sofort an das Anwenderprogramm weitergegeben 
(URG-Code muß gesetzt sein).  Der Wert des Urgent-Pointers markiert 
das letzte abzuliefernde Byte; es hat die Nummer &lt;Sequence Number&gt; 
+ &lt;Urgent Pointer&gt;.

</dd><dt>Options
</dt><dd>Dieses Feld dient dem Informationsaustausch zwischen beiden Stationen auf 
der TCP-Ebene, z. B. die Segmentgröße (die Ihrerseits von der 
Größe des IP-Datagramms abhängen sollte, um den Durchsatz 
im Netz optimal zu gestalten).
</dd></dl>
<p>

</p><h4>Ablauf einer TCP-Session</h4>
Im Gegensatz zu IP ist TCP <b>verbindungsorientiert</b>. Das muß so sein, 
denn TCP-Verbindungen sollen ja für den Benutzer prinzipiell wie Dateien zu 
handhaben sein. Das bedeutet, eine TCP-Verbindung wird wie eine Datei geöffnet und
geschlossen, und man kann ihre Position innerhalb des Datenstroms bestimmen, genau 
wie man bei einer Datei die Position der Lese- oder Schreibposition angeben kann. 
TCP sendet die Daten auch in größeren Einheiten, um den Verwaltungsaufwand 
durch Header- und Kontrollinformationen klein zu halten. Im Gegensatz zu
den IP-Paketen bezeichnet man die Einheiten der Transportschicht als "Segmente". 
Jedes gesendete TCP-Segment hat eine eindeutige Folgenummer, welche die Position 
seines ersten Bytes im Byte-Strom der Verbindung angibt. Anhand dieser Nummer 
kann die Reihenfolge der Segmente korrigiert und doppelt angekommene Segmente 
können aussortiert werden. Da die Länge des Segments aus dem IP-Header
bekannt ist, können auch Lücken im Datenstrom entdeckt werden, und der 
Empfänger kann verlorengegangene Segmente neu anfordern.
<p>
Beim Öffnen einer TCP-Verbindung tauschen beide Kommunikationspartner 
Kontrollinformationen aus, die sicherstellen, daß der jeweilige Partner 
existiert und Daten annehmen kann. Dazu schickt die Station A ein Segment mit der
Aufforderung, die Folgenummern zu synchronisieren. <br>
Das einleitende Paket mit gesetztem SYN-Bit ("Synchronise-" oder "Open"-Request)
gibt die Anfangs-"Sequence Number" des Client bekannt. Diese Anfangs-"Sequence
Number wird zufällig bestimmt. Bei allen nachfolgenden Paketen ist das
ACK-Bit ("Acknowledge", "Quittung") gesetzt. Der Server antwortet mit ACK, SYN
und der Client bestätigt mit ACK. Das sieht dann so aus:
</p><p>
</p><center><img src="TCP_IP-Dateien/tcp-hs1.gif"></center>
<p>
Die Station B weiß jetzt, daß
der Sender eine Verbindung öffnen möchte und an welcher
Position im Datenstrom der Sender anfangen wird zu zählen. Sie
bestätigt den Empfang der Nachricht und legt ihrerseits eine
Folgenummer für Übertragungen in Gegenrichtung fest. 
</p><p>
</p><center><img src="TCP_IP-Dateien/tcp-hs2.gif"></center>
<p>
Station A bestätigt nun den Empfang der Folgenummer von B und beginnt 
dann mit der Übertragung von Daten. 
</p><p>
</p><center><img src="TCP_IP-Dateien/tcp-hs3.gif"></center>
<p>
Diese Art des Austausches von Kontrollinformationen, bei der jede Seite die Aktionen 
der Gegenseite bestätigen muß, ehe sie wirksam werden können, 
heißt "Dreiwege-Handshake". Auch beim Abbau einer Verbindung wird auf diese 
Weise sichergestellt, daß beide Seiten alle Daten korrekt und vollständig 
empfangen haben. Im zeitlichen Zusammenhang stellt sich eine TCP/IP-Verbindung
folgendermaßen dar:
</p><p>
</p><center><img src="TCP_IP-Dateien/tcpip2.gif"></center>
<p>
Das folgende Beispiel zeigt die Arbeitsweise des TCP/IP - Protokolls. Es wird
eine Nachricht von einem Rechner im grünen Netz zu einem Rechner im orangen
Netz gesendet.
</p><p>
<table border="0" cellpadding="5">
<tbody><tr>
<td valign="TOP"><img src="TCP_IP-Dateien/tcpbsp1.gif"></td>
<td valign="TOP">
Die Nachricht wird in mehrere Pakete aufgeteilt und auf der besten Route 
auf die Reise geschickt. Das verbindungslose IP-Protokoll sorgt zusammen mit
den Routern für den Weg.</td>
</tr><tr>
<td valign="TOP">
Da eine Strecke überlastet ist, werden die Pakete 3, 4 und 5 auf einer 
anderen Strecke weiter transportiert. Dieser Transport erfolgt zufälligerweise 
schneller als jener der Pakete 1 und 2.</td>
<td valign="TOP"><img src="TCP_IP-Dateien/tcpbsp2.gif"></td>
</tr><tr>
<td valign="TOP"><img src="TCP_IP-Dateien/tcpbsp3.gif"></td>
<td valign="TOP">
Die Pakete wandern ihrem Bestimmungsnetz entgegen. Das erste Paket ist 
bereits angekommen. Paket 3 kommt vor Paket 2 am Ziel an.</td>
</tr><tr>
<td valign="TOP">
Die Pakete 1, 2 und 3 sind - in falscher Reihenfolge - am Zielrechner angekommen. 
Auf der Strecke, auf der Pakete 4 und 5 transportiert werden, tritt eine Störung 
auf.</td>
<td valign="TOP"><img src="TCP_IP-Dateien/tcpbsp4.gif"></td>
</tr><tr>
<td valign="TOP"><img src="TCP_IP-Dateien/tcpbsp5.gif"></td>
<td valign="TOP">
Paket 4 ist bei der Störung verloren gegangen. Paket 5 wird auf einer 
anderen Route zum Zielnetz geschickt (wären die Routen statisch am Router 
eingetragen, ginge auch Paket 5 verloren).</td>
</tr><tr>
<td valign="TOP">
Alle überlebenden Pakete sind am Zielrechner angekommen. Das TCP-Protokoll 
setzt die Pakete wieder in der richtigen Reihenfolge zusammen und fordert das
fehlende Paket 4 nochmals beim Sender an. Für den Empfänger ergibt sich
ein kontinuierlicher Datenstrom.</td>
<td valign="TOP"><img src="TCP_IP-Dateien/tcpbsp6.gif"></td>
</tr>
</tbody></table>
</p><p>

</p><h4>TCP-Zustandsübergangsdiagramm</h4>
Den gesamte Lebenszyklus einer TCP-Verbindung beschreibt die folgende Grafik in einer 
relativ groben Darstellung. 
<p>
</p><center><img src="TCP_IP-Dateien/tcpzust.gif"></center>
<p>
Erklärung der Zustände:
</p><ul>
<li> LISTEN: Warten auf ein Connection Request.
</li><li> SYN-SENT: Warten auf ein passendes Connection Request, 
nachdem ein SYN gesendet wurde.
</li><li>SYN-RECEIVED: Warten auf Bestätigung des Connection Request
Acknowledgement, nachdem beide Teilnehmer ein Connection Request 
empfangen und gesendet haben.
</li><li>ESTABLISHED: Offene Verbindung.
</li><li>FIN-WAIT-1: Warten auf ein Connection Termination Request des Kommunikationspartners 
oder auf eine Bestätigung des Connection Termination, das vorher gesendet wurde.
</li><li>FIN-WAIT-2: Warten auf ein Connection Termination Request des Kommunikationspartners.
</li><li>CLOSE-WAIT: Warten auf ein Connection Termination Request (CLOSE) der darüberliegenden 
Schicht.
</li><li>CLOSING: Warten auf ein Connection Termination Request des Kommunikationspartners.
LAST-ACK: Warten auf die Bestätigung des Connection Termination Request, das zuvor an 
den Kommunikationspartner gesendet wurde.
</li></ul>
<p>

</p><h3>Zeitüberwachung</h3>

In allen Protokollimplementierungen spielt die Zeit eine wichtige Rolle. So werden
alle Abläufe zeitlich überwacht. Dazu werden in der Protokollimplementierung
sogenannte "Timer" gestartet, deren Timeout zur Fehlerbehandlung führt.
<p>

</p><h4>Paketwiederholungs-Wecker oder Retransmission Timeout</h4>

In Weitverkehrsnetzen mit unterschiedlichsten Verbindungsarten, die noch dazu 
zeitlichen Schwankungen unterworfen sind, ist die Wahl der Wartezeit auf 
Bestätigungen schwierig. 
Der Retransmission Timeout (RTO) läuft ab, wenn der vorgegebene Zeitraum 
zwischen dem Aussenden eines TCP-Pakets bis zum Eintreffen der dazugehörigen 
Quittung überschritten wird. In diesem Fall muß das Paket noch einmal 
gesendet werden. Allerdings darf der Zeitraum nicht fest definiert sein, da man 
sonst TCP nicht über Netzwerke mit unterschiedlichen Laufzeiten betreiben 
könnte - wenn man z.B. Ethernet und eine serielle Verbindung über mehrere
Gateways miteinander vergleicht, ergibt sich ein tausendfacher Unterschied in der 
Übertragungsrate. Daher wird in TCP bei jedem Paket die Zeit gemessen, die 
zwischen Senden und Empfangen einer Quittung vergeht, die sogenannte <i>Round Trip Time 
(RTT)</i>. Die so gemessene Zeit wird über eine Formel umgerechnet, die Spitzen 
nach oben und unten herausfiltert, sich aber auch allmählich an eine
verlängerte oder verkürzte Laufzeit anpaßt. Das Ergebnis ist die 
<i>Smoothed Round Trip Time (SRTT)</i>, d.h. die mittlere Zeit, die für einen
Paketaustausch verstreicht. Diese Zeit wird nochmals skaliert, um weiteren Spielraum 
für unvorhergesehene Verzögerungen zu schaffen.
<pre>SRTT:     S = aS + (1 - a)R
RTO:      T = min[U, max[L,ßS]]
          (L &lt; T &lt; U)
</pre>
 S Smoothed Round Trip Time<br>
 R Round Trip Time<br>
 T Retransmission Timeout (z.B. 30 Sekunden)<br>
 U Zeitobergrenze (z.B. 1 Sekunde)<br>
 L Zeituntergrenze (z.B. 1 Minute)<br>
 a Smoothing Factor (z.B. 0.9)<br>
 ß Scaling Factor (z.B. 2.0)<br>
<p>
Die beiden Formeln werden durch den RFC 793 spezifiziert: zunächst den SRTT-Filter, 
danach die Ermittlung des RTO. Falls nach der Wiederholung des Pakets der Wiederholungstimer
ein weiteres Mal abläuft, wird der RTO in der Regel bis zu zwölfmal exponentiell 
erhöht. Erst wenn auch diese Erhöhung keinen Effekt zeigt, gilt die Verbindung als 
unterbrochen.
</p><p>

</p><h4>Persistance Timer</h4>
Beim Austausch von Daten über TCP ist es im Prinzip möglich, daß 
das Empfangsfenster gerade auf 0 steht - und genau in diesem Moment ein Paket 
verlorengeht, das das Fenster wieder öffnen sollte. Als Ergebnis warten 
dann beide TCPs bis in alle Ewigkeit aufeinander. Ein Gegenmittel dazu ist der 
Persistenz-Timer, der in bestimmten Zeitabschnitten kleine TCP-Pakete 
(1 Byte) abschickt und damit überprüft, ob die Empfängerseite wieder
bereit ist. Ist das Empfangsfenster nach wie vor 0, kommt eine negative Quittung 
zurück; ist es größer, können nach der positiven Quittung 
weitere Daten gesendet werden.
<p>

</p><h4>Stillhaltezeit oder Quiet Time</h4>
Jede Möglichkeit der Verwechslung von Verbindungen durch im Netz herumirrende 
überholte TCP-Pakete sollte verhindert werden. Daher werden nach dem Abbau 
von TCP-Verbindungen Portnummern erst wieder freigegeben, wenn eine bestimmte Zeitspanne, 
die zweimal die "Maximum Segment Lifetime" (MSL) beträgt, vergangen ist. Die MSL 
entspricht der Zeit, in UNIX die im TTL-Feld von IP eingetragen wird.
Der UNIX-Anwender bemerkt diese Wartezeit, wenn er eine Verbindung zwischen 
gleichen Partnern (d.h. gleichen Portnummern) sofort nach dem Abbruch wieder 
eröffnen will. Das System teilt ihm dann mit, daß die verwendete 
Portnummer noch belegt ist. Erst nach Ablauf von ca. 30 Sekunden ist ein erneuter 
Verbindungsaufbau möglich.
<p>

</p><h4>Keep Alive Timer und Idle Timer</h4>
Dabei handelt es sich um zwei nicht in der TCP-Spezifikation vorgesehene Wecker, die 
aber in UNIX-Systemen implementiert sind. Beide stehen miteinander in Verbindung. 
Der Keep Alive Timer bewirkt, daß in regelmäßigen Zeitabständen 
ein leeres Paket abgeschickt wird, um das Bestehen der Verbindung zum Partner zu 
überprüfen. Antwortet der Partnerrechner nicht, wird die Verbindung 
nach Ablauf des Idle Timers abgebrochen. Eine Applikation aktiviert diese Timer mit 
der KEEP_ALIVE-Option über die Socket-Schnittstelle. 
In der folgenden Tabelle sind die Werte für die oben genannten Timer angegeben. 
Dazu ist zu bemerken, daß die Dauer der Timer implementationsabhängig ist 
und nicht immer auf die unten angegebenen Werte eingestellt sein muß. 
<p>

<table border="1" cellpadding="3" cellspacing="0">
<tbody><tr><th colspan="2">Einstellungen der TCP-Timer (implementationsabhängig)</th></tr>
<tr><th>Timer</th><th>Dauer [s]</th></tr>
<tr><td>Retransmission Timeout</td><td>dynamisch</td></tr>
<tr><td>Persistance Timer</td><td>5</td></tr>
<tr><td>Quiet Timer</td><td>30</td></tr>
<tr><td>Keep Alive Timer</td><td>45</td></tr>
<tr><td>Idle Timer</td><td>360</td></tr>
</tbody></table>
</p><p>


</p><h3>Algorithmen zur Steigerung der Effizienz</h3>

Zwischen einer TCP-Implementierung nach Spezifikation und einem optimierten TCP-Subsystem, 
wie man es in UNIX-Systemen vorfindet, liegt ein weiter Weg. Zahllose Verbesserungen 
sind in den Jahren in die UNIX-TCP-Implementierungen eingeflossen und neue Algorithmen 
in Nachfolgeversionen integriert worden:
<p>

</p><h4>Acknowledgement Delay</h4>
Normalerweise sendet der Empfänger nach Erhalt eines Pakets ein Antwortpaket, 
in dem die Größe des Empfangsfensters verkleinert und die Daten quittiert 
werden. Nach Übergabe der Daten an den empfangenden Prozeß werden die Datenpuffer 
im System frei, was ein Absenden eines Pakets mit einer Vergrößerung des 
Empfangsfensters zur Folge hat. Hat das Programm die Daten verarbeitet, folgt in der 
Regel kurz danach eine Antwort, es sind also für eine Transaktion in der Regel drei 
Pakete notwendig. Man hat aber festgestellt, daß in manchen Fällen, z.B. beim 
Telnet- oder SSH-Betrieb, ein Verzögern des Quittungspakets um 0,2 Sekunden 
Vorteile bringt: nach dieser kurzen Wartezeit können alle drei Informationen - 
Empfangsfenster, Quittung und Antwort - in einem einzigen Paket versendet werden. Damit 
Datentransfers, die hohen Durchsatz benötigen, nicht gebremst werden, unterbleibt die
Verzögerung, wenn das Empfangsfenster um mindestens 35% oder zwei maximale Pakete 
verändert wurde.
<p>


</p><h4>Silly Window Syndrome Avoidance</h4>
In bestimmten Situationen werden Empfangsfensterangaben versendet, die derart klein sind, 
daß das Netzwerk und Rechner von den vielen Quittungspaketen über Gebühr 
belastet werden. Um das zu verhindern, wird das Empfangsfenster nur dann wieder 
vergrößert, wenn ausreichend Platz (mehr als 1/4 des Datenpuffers oder ein 
maximales Paket) zur Verfügung steht. Desgleichen verhält sich auch der 
Sender konservativ und sendet nur, wenn das angebotene Fenster ausreichend groß ist. 
<p>

</p><h4>Nagle Algorithm oder Small Packet Avoidance</h4>
Benannt nach 
 seinem Erfinder John Nagle, versucht dieser Algorithmus eben-
 falls, das Versenden von kleinen TCP-Paketen zu verhindern. do,
 In diesem Fall geht es aber darum, auf der Senderseite zu verhin- es
 dern, daß in kleinen Einheiten von der Applikation an TCP über- Ari
 gebene Daten auch in dieser Form weiterversendet werden. Ein Co
 erstes Paket wird sofort ausgesendet, weitere Daten auf der ge,~
 Senderseite aber so lange gepuffert, bis ein volles maximales Seg- un
 ment geschickt werden kann oder eine Quittung für das erste gn
 Paket eingetroffen ist. Probleme ergeben sich mit diesem bis
 Algorithmus aber bei Anwendungen, die viele kleine Nachrich- un
 ten abschicken, ohne eine Antwort zurückzuerhalten, z.B. dem X In
 Window System. In diesem Fall kann der Nagle-Algorithmus En
 verbindungsspezifisch abgeschaltet werden. pal

<h4>Slow Start with Congestion Avoidance</h4>
Diese miteinander verbundenen Algorithmen, manchmal auch als Jacobson-Algorithmen
bezeichnet, sind erst in jüngster Zeit bekannt geworden und in erster 
Linie für langsame Netzwerke und den Betrieb von Netzen mit Gateways von 
Bedeutung.  Man hatte in den letzten Jahren beobachtet, daß das Internet mit 
steigender Belastung immer weniger Datendurchsatz lieferte und zum Teil sogar 
nahezu zusammenbrach. Als man die Vorgänge näher betrachtete, wurde 
festgestellt, daß mehr als die Hälfte der Daten Wiederholungen 
verlorengegangener TCP-Pakete waren. Was war geschehen? Ein Netzwerkpfad - 
Datenpuffer vom Sender über mögliche Gateways bis hin zum
Empfänger - kann nur eine endliche Datenmenge aufnehmen.
Wenn ein Gateway oder ein Host sehr durch Verkehr belastet sind, kann es 
vorkommen, daß nicht genügend Pufferplatz zur Aufnahme von Paketen 
vorhanden ist. In diesem Fall werden die Pakete vom Gateway verworfen, 
woraufhin der Absender des Pakets nach Ablauf des Retransmission Timeouts
eine Wiederholung vornimmt und dadurch insgesamt die Belastung des Netzes weiter 
unnötig steigert. Der Slow Start-Algorithmus versucht nun zu ermitteln, wieviele 
Daten zu einem Zeitpunkt in Richtung Empfänger unterwegs sein können, ohne 
daß es dabei zu Verlusten kommt. Erreicht wird das über eine allmähliche 
Steigerung der ausgesendeten Datenmenge bis zu einem Punkt, an dem sich ein 
gleichmässiger Datenfluß ohne Wiederholungen ergibt. Wo früher
die Menge der auszusendenden Daten durch die Größe bestimmt wurde, 
ist jetzt die Aufnahmekapazität des Netzwerkpfads, das sogenannte "Congestion Window", 
die bestimmende Größe, wobei das Congestion Window immer kleiner oder gleich 
dem Empfangsfenster (Receive Window) ist. Hat sich das Congestion Window eingependelt, 
wird es erst wieder verändert, wenn auftretende Wiederholungen ein Ansteigen der 
Netzwerklast signalisieren: in diesem Fall tritt die "Congestion Avoidance" in Kraft. 
Gleichzeitig wird durch ständiges vorsichtiges Vergrößern des Congestion 
Windows versucht, unter Umständen freiwerdende Ressourcen zu benutzen. Aufgrund des
konservativen Verhaltens läßt sich der Durchsatz um bis zu 30% steigern und 
die Anzahl der wiederholten Pakete um über 50% senken. In Verbindung mit diesen 
beiden Algorithmen wurde auch die Ermittlung des Retransmission Timeouts verbessert. 
Dieser Wert paßt sich jetzt schneller an Veränderungen in der RTT an und
verhindert zusätzliche Paketwiederholungen.
<p>


</p><h3>Ports für jeden Dienst</h3>
Server-Prozesse lauschen bei UDP und TCP auf bestimmten Portnummern. Per 
Übereinkunft werden dazu Ports niedriger Nummern verwendet. Für 
die Standarddienste sind diese Portnummern in den RFCs festgeschrieben. 
Ein Port im "listen"-Modus ist gewissermaßen eine halboffene Verbindung. 
Nur Quell-IP und Quellport sind bekannt. Der Serverprozeß kann vom 
Betriebssystem dupliziert werden, so daß weitere Anfragen auf diesem 
Port behandelt werden können.
<p>
</p><ul>
<li>Die Portnummern werden auf dem Host-System konfiguriert und haben zwei Funktionen:
  <ul>
  <li>Allgemein verfügbare Dienste werden über 'well known' Ports 
       (--&gt; feste, per RFC zugeordnete Portnummer) erreichbar. Sie stehen 
       also für ein Protokoll, das über die Nummer direkt 
       angesprochen wird
  </li><li>oder sie werden beim Verbindungsaufbau vereinbart und einem 
       Server-Programm zugewiesen
  </li></ul>
</li><li>Die Portangabe ist nötig, wenn mehrere Serverprogramme auf dem 
adressierten Rechner laufen.
</li><li>Die Portnummer steht im TCP-Header und ist 16 Bit groß. Theoretisch 
können also bis zu 65535 TCP-Verbindungen auf einem Rechner mit einer einzigen 
IP-Adresse aufgebaut werden.
</li><li>Portnummern werden oft auch bei der Konfiguration von Internet-Clients 
als Parameter gefordert.
</li><li>Die Client-Prozesse verwenden normalerweise freie Portnummern, die vom
lokalen Betriebssystem zugewiesen werden (Portnummer &gt; 1024).
</li></ul>
<p>
</p><center><img src="TCP_IP-Dateien/ports.gif"></center>
<p>
Die "well known" Portnummern (0 bis 1023), die weltweit eindeutig adressiert 
werden müssen, werden durch die IANA (Internet Assigned Numbers Authority) 
vergeben. Einige Beispiele für TCP-Ports (UDP verwendet eine andere
Zuordnung):
</p><p>
<table border="1" cellpadding="4">
<tbody><tr><th>Portnummer</th><th>Protokoll</th></tr>
<tr><td>20</td><td>FTP (Daten)</td></tr>
<tr><td>21</td><td>FTP (Befehle)</td></tr>
<tr><td>22</td><td>Secure Shell</td></tr>
<tr><td>23</td><td>Telnet</td></tr>
<tr><td>25</td><td>SMTP</td></tr>
<tr><td>53</td><td>DNS-Server</td></tr>
<tr><td>70</td><td>Gopher</td></tr>
<tr><td>79</td><td>Finger</td></tr>
<tr><td>80</td><td>HTTP (Proxy-Server)</td></tr>
<tr><td>110</td><td>POP3</td></tr>
<tr><td>119</td><td>NNTP</td></tr>
<tr><td>143</td><td>IMAP</td></tr>
<tr><td>194</td><td>IRC</td></tr>
<tr><td>210</td><td>WAIS</td></tr>
<tr><td>256 - 1023</td><td>UNIX-spezifische Services</td></tr>
<tr><td>540</td><td>UUCP</td></tr>
<tr><td>1024 - 49151</td><td>Registered Ports</td></tr>
<tr><td>49152 - 65535</td><td>Dynamic / Private Ports</td></tr>
</tbody></table>
</p><p>
Eine vollständige Portliste erhält man bei 
<a href="https://web.archive.org/web/20070611100850/http://www.isi.edu/in-notes/iana/assignments/port-numbers" target="_blank">http://www.isi.edu/in-notes/iana/assignments/port-numbers</a>.
</p><p>
IP-Adresse und Portnummer definieren einen Kommunikationsendpunkt, der in der 
TCP/IP-Welt "Socket" genannt wird. 
Die Grenze zwischen der Anwendungsschicht und der Transportschicht ist in den meisten
Implementierungen zugleich die Grenze zwischen dem Betriebssystem und den 
Anwendungsprogrammen. Im OSI-Modell ist diese Grenze in etwa die Grenze zwischen 
den Schichten 4 und 5. Daher ordnet man IP meist ungefähr in die Ebene 3 und 
TCP ungefähr in Ebene 4 des OSI-Modells ein. Da TCP/IP jedoch älter und
einfacher als das OSI-Modell ist, kann diese Einordnung nicht genau passen.
</p><p>

</p><h4>Port-Scans</h4>
Beim Scanning wird versucht, offene Ports eines Rechners zu ermitteln. Das ist
meist auch der erste Schritt eines Angreifers, der in einem Rechner eindringen will.
Deshalb dient ein Portscan auch dazu, die Sicherheit des eigenen Systems zu 
überprüfen. Bei den Scanning-Methoden wurden Verfahren entwickelt, bei denen
versucht wird, den Scanvorgang auf dem gescannten Rechern unentdeckt zu lassen.
<ul>
<li><i>TCP-Connect-Scan</i><br>
Bei dieser Methode wird versucht, eine Verbindung zu einem Port auf
dem Zielrechner aufzubauen. Der Scanner läßt einen vollständigen 
Dreiwege-Handshake zu, bevor er die Verbindung wieder unterbricht. 
Diese Art der Scans ist allerdings sehr leicht zu entdecken und 
kann auch leicht mit Hilfe von Firewalls abgeblockt werden.
<p>
</p></li><li><i>TCP-SYN-Scan</i><br>
Diese Methode wird oft als "Half-Open-Scan" bezeichnet. Der Scanner sendet 
ein SYN-Packet an den Zielrechner, wie bei einem ganz normalen Verbindungsaufbau.
Wenn der Zielrechner mit einem RST antwortet, weiß der Scanner, daß dieser
Port geschlossen ist. Antwortet der Zielrechner jedoch mit einem SYN/ACK, handelt
es sich um einem offenen Port. In diesem Falle wird die Verbindung vom Scanner sofort
mit einem RST beendet. Diese Art des Scannens ist nicht ganz so leicht auf dem
Zielrechner zu entdecken wie der Connect Scan.
<p>

</p></li><li><i>Stealth FIN-Scan</i><br>
Stealth Scans sollen vom Zielrechner nicht entdeckt werden. Allerdings
gibt es Programme, die genau solche Scans entdecken. Beim "Stealth FIN Scan" 
wird nur ein Packet mit einem FIN-Flag, ohne begleitendes ACK-Flag gesendet.
Diese Art von Paket ist unzulässig. Wenn der Port offen ist, wird das Paket des
Scanners vom Zielrechner ignoriert. Wenn der Port geschlossen ist, antwortet der
Zielrechner mit einem RST-Paket. 
<p>
</p></li><li><i>Stealth Xmastree-Scan</i><br>
Bei diesem Scan sind die FIN-, URG-, und PUSH-Flags alle gemeinsam gesetzt. Auch
dieses Paket ist unzulässig. Wenn der Port offen ist, wird das Paket des
Scanners vom Zielrechner ignoriert. Wenn der Port geschlossen ist, antwortet der
Zielrechner mit einem RST-Paket.
<p> 
</p></li><li><i>Stealth Null-Scan</i><br>
Bei diesem Scan sind alle Flags auf Null gesetzt. Alles Weitere wie oben.
<p>
</p></li><li><i>ACK-Scan</i><br>
Dieser Scan wird verwendet, um Firewalls zu testen ob sie mit "stateful inspection" 
arbeiten (z.B. Firewall 1) oder ob es sich nur um einfache Packetfilter handelt, 
die eingehende SYN Packete verwerfen. Der ACK-Scan sendet
ein Packet mit gesetztem ACK-Flag und zufälliger Sequenznummer an die Ports.
Wenn das Paket von der Firewall durchgelassen wird, sendet der Server ein RST, da
das Paket nicht zuzuordnen ist. In diesem Fall wird der Port als "ungefiltert" 
klassifiziert. Wenn die Firewall den Status einer Verbindung überwacht, wird 
das Paket ohne eine Antwort vom Zielrechner abgewiesen oder es wird dem 
Scanner mit einer ICMP Destination unreachable Nachricht geantwortet.
</li></ul>
<p>

</p><h2><a name="8.7">PPP</a></h2>
Das <b>Point to Point Protocol</b> (PPP) findet gegenwärtig vielfachen 
Einsatz. Es arbeitet mit drei Teilprotokollen:
<ul>
<li> Das Data Link Layer Protocol ermöglicht die Übertragung 
(Encapsulation) von Datagrammen über serielle Verbindungen mit Hilfe von HDLC.
</li><li> Das Link Control Protocol (LCP) steuert Aufbau, Konfiguration und 
Test der Verbindung.
</li><li> Das Network Control Protocol (NCP) ermöglicht die Übertragung 
von Konfigurationsdaten für verschiedene Protokolle der Vermittlungsschicht.
</li></ul>
PPP ist geeignet für den simultanen Einsatz verschiedener Protokolle der 
Vermittlungsschicht, es ist also ein so genanntes "Multi-Protokoll-Protokoll". 
Es ist ein zustandsorientiertes Protokoll:
<p>
</p><center><img src="TCP_IP-Dateien/ppp2.gif"></center>
<p>
PPP ist ein verbindungsorientiertes Protokoll und unterscheidet drei Phasen 
Verbindungsaufbau, Datenübertragung und Verbindungsabbau. Die Realisierung 
dieser Phasen unter Berücksichtigung der Teilprotokolle von PPP zeigt 
das Bild unten.
</p><ol>
<li> Der anrufende PPP-Knoten sendet LCP-Rahmen zum Aufbau und zur Konfiguration der
Verbindung (Data Link). Die LCP-Pakete verfügen über ein Feld mit 
Konfigurations-Optionen. Zu diesen Optionen zählen beispielsweise die
Maximum Transmission Unit (MTU). Hierbei handelt es sich um die Angabe, ob 
bestimmte PPP-Felder komprimiert werden, oder das Link Authentication Protocol
(LAP).
</li><li>In einer optionalen Phase wird überprüft, ob die Qualität der 
Verbindung für den Aufbau einer Übertragung der Pakete der Vermittlungsschicht 
ausreicht.
</li><li> Es folgt eine Authentifizierungsphase.
</li><li> Der anrufende PPP-Knoten sendet NCP-Rahmen zur Auswahl und Konfiguration des zu
übertragenden Protokolls der Vermittlungsschicht.
</li><li> Nun können die Daten übertragen werden.
</li><li> Die Verbindung bleibt bis zur Beendigung durch LCP- oder NCP-Rahmen bestehen 
oder bis ein externes Ereignis auftritt. Zu diesen kann eine Unterbrechung durch den 
Anwender, der Abbruch der Übertragung oder der Ablauf eines "Inactivity Timers"
zählen.
</li></ol>
<p>
</p><center><img src="TCP_IP-Dateien/ppp3.gif"></center>
<p>
PPP unterstützt verschiedene Protokolle zur Authentifizierung. Dabei realisieren 
alle Protokolle nur eine einseitige Authentifizierung. Dies bedeutet, dass sich der
anrufende Knoten bzw. dessen Anwender authentifizieren und der angerufene Knoten diese
Authentifizierung überprüfen muss. Der angerufene Knoten authentifiziert 
sich durch seine Verfügbarkeit unter dieser physischen Verbindung. Die
wichtigsten Authentifizierungsprotokolle sind:
</p><ul>
<li>das Password Authentication Protocol (PAP),
</li><li>das Shiva Password Authentication Protocol(SPAP),
</li><li>das Challenge Handshake Authentication Protocol (CHAP) sowie
</li><li>eine Variante des CHAP, das Microsoft-CHAP (MS-CHAP), das in zwei Versionen vorliegt.
</li></ul>
<p>
Die Authentifzierungsprotokolle mit der größten Verbreitung sind PPP und CHAP. Auch
MS-CHAPv2 ist recht häufig anzutreffen. Die meisten ISPs fragen beim einwählenden Host
zunächst CHAP an.
</p><p>
<b>PAP</b> unterstützt ein so genanntes Zwei-Wege-Handshake. Die Kombination "Username/Password" 
wird vom anrufenden Knoten so lange übertragen, bis die Authentifizierung bestätigt 
oder abgelehnt wird. Im Falle der Ablehnung wird die Verbindung abgebrochen. Dieses Vorgehen 
bietet allerdings nur eine geringe Sicherheit: Das Passwort wird unverschlüsselt übertragen. 
Es ist eine beliebige Anzahl von Wiederholungen möglich. Und schließlich werden 
Häufigkeit und Geschwindigkeit der Versuche vom anrufenden Knoten bestimmt, so dass ein 
Brute-Force-Angriff möglich wird.
</p><p>
<b>CHAP</b> bietet ein erhöhtes Sicherheitsniveau im Rahmen eines so genannten Drei-Wege-Handshakes. 
Der anrufende Knoten darf erst die Authentifizierung beginnen, wenn er vom angerufenen Knoten dazu 
aufgefordert wurde. Auf diese Weise werden Häufigkeit und Geschwindigkeit der Versuche vom 
angerufenen Knoten bestimmt. Zusätzlich wird die Kombination "Username/Password" nur im Rahmen 
einer Ein-Wege-Hash-Funktion (Message Digest 5, MD5) übertragen. Die Überprüfung 
kann also nicht nur beim Verbindungsaufbau, sondern auch periodisch während der Verbindung 
stattfinden.
</p><p>

</p><h2><a name="8.8">IP Next Generation</a></h2>
Das rasche (exponentielle Wachstum) des Internet zwingt dazu, das Internet Protokoll 
in der Version 4 (IPv4) durch ein Nachfolgeprotokoll (IPv6 Internet Protocol 
Version 6) zu ersetzen.
<p>
Vinton Cerf (der 'Vater' des Internet) bezeichnet in einem Interview mit der Zeitschrift 
c't das Internet <i>"(...) als die wichtigste Infrastruktur für alle Arten 
von Kommunikation."</i>. Auf die Frage, wie man sich die neuen Kommunikationsdienste 
des Internet vorstellen könne, antwortete Cerf:
</p><p>
</p><blockquote>
<i>"Am spannendsten finde ich es, die ganzen Haushaltsgeräte ans Netz anzuschließen. Ich denke
dabei nicht nur daran, daß der Kühlschrank sich in Zukunft mit der Heizung austauscht, ob es in der
Küche zu warm ist. Stromgesellschaften könnten beispielsweise Geräte wie Geschirrspülmaschinen
kontrollieren und ihnen Strom genau dann zur Verfügung stellen, wenn gerade keine Spitzennachfrage herrscht.
Derartige Anwendungen hängen allerdings davon ab, daß sie zu einem erschwinglichen Preis angeboten werden.
Das ist nicht unbedingt ferne Zukunftsmusik; die Programmierer müßten eigentlich nur damit anfangen,
endlich Software für intelligente Netzwerkanwendungen zu schreiben. Und natürlich muß die Sicherheit
derartiger Systeme garantiert sein. Schließlich möchte ich nicht, daß die Nachbarkinder mein Haus
programmieren!"</i>
</blockquote>
<p>
Auf die Internet Protokolle kommen in der nächsten Zeit also völlig neue 
Anforderungen zu. 
</p><p>

</p><h2>Classless InterDomain Routing - CIDR</h2>
<p>Der Verknappung der Internet-Adressen durch die ständig steigende Benutzerzahl 
wird zunächst versucht, mit dem <i>Classless Inter-Domain Routing (CIDR)</i> 
entgegen zu wirken.
Durch die Vergabe von Internet-Adressen in Klassen (A,B,C,...) wird eine große Anzahl
von Adressen verschwendet. Hierbei stellt sich vor allem die Klasse B als Problem dar. 
Viele Firmen nehmen ein Netz der Klasse B für sich in Anspruch, da ein Klasse A Netz 
mit bis zu 16 Mio. Hosts selbst für eine sehr große Firma überdimensioniert 
scheint, ein Netz der Klasse C mit 254 Hosts aber zu klein.
</p><p>
Ein größerer Host-Bereich für Netze der Klasse C (z. B. 10 Bit, 1022 Hosts 
pro Netz) hätte das Problem der knapper werdenden IP-Adressen vermutlich gemildert. 
Ein anderes Problem wäre dadurch allerdings entstanden: die Einträge der 
Routing-Tabellen hätten sich um ein Vielfaches vermehrt.
</p><p>
Ein anderes Konzept ist das Classless Inter-Domain Routing (RFC 1519): die verbleibenden 
Netze der Klasse C werden in Blöcken variabler Größe zugewiesen. Werden 
beispielsweise 2000 Adressen benötigt, so können einfach acht aufeinanderfolgende 
Netze der Klasse C vergeben werden. Zusätzlich werden die verbliebenen Klasse-C-Adressen 
restriktiver und strukturierter vergeben (RFC 1519). Die Welt ist dabei in vier Zonen 
aufgeteilt, von denen jede einen Teil des verbliebenen Klasse C Adreßraums erhält:
</p><p>
</p><center>
<table border="1" cellpadding="4" bgcolor="#CCCCCC">
<tbody><tr><td>194.0.0.0 - 195.255.255.255</td><td>Europa</td></tr>
<tr><td>198.0.0.0 - 199.255.255.255</td><td>Nordamerika</td></tr>
<tr><td>200.0.0.0 - 201.255.255.255</td><td>Mittel- und Südamerika</td></tr>
<tr><td>202.0.0.0 - 203.255.255.255</td><td>Asien und pazifischer Raum</td></tr>
<tr><td>204.0.0.0 - 223.255.255.255</td><td>Reserviert für zukünftige Nutzung</td></tr>
</tbody></table>
</center>
<p>
Jede der Zonen erhält dadurch in etwa 32 Millionen Adressen zugewiesen. Vorteil bei 
diesem Vorgehen ist, daß die Adressen einer Region im Prinzip zu einem Eintrag in 
den Routing-Tabellen komprimiert worden sind und jeder Router, der eine Adresse 
außerhalb seiner Region zugesandt bekommt diese getrost ignorieren darf.
</p><p>

</p><h3>Internet Protokoll Version 6 - IPv6 (IP Next Generation, IPnG)</h3>
Der vorrangige Grund für eine Änderung des IP-Protokolls ist auf den 
begrenzten Adreßraum und das Anwachsen der Routing-Tabellen zurückzuführen.
CIDR schafft hier zwar wieder etwas Luft, dennoch ist klar absehbar, daß auch 
diese Maßnahme nicht ausreicht, um die Verknappung der Adressen für eine 
längere Zeit in den Griff zu bekommen. Weitere Gründe für eine 
Änderung des IP-Protokolls sind die neuen Anforderungen an das Internet, denen IPv4
nicht gewachsen ist. Streaming-Verfahren wie Real-Audio oder Video-on-Demand erfordern
das Festlegen eines Mindestdurchsatzes, der nicht unterschritten werden darf. Bei IPv4
kann so ein "Quality of Service" jedoch nicht definiert - und damit auch nicht 
sichergestellt - werden. Die <i>IETF (Internet Engineering Task Force)</i> begann 
deshalb 1990 mit der Arbeit an einer neuen Version von IP. Die wesentlichen Ziele des 
Projekts sind:
<ul>
<li>Unterstützung von Milliarden von Hosts, auch bei ineffizienter Nutzung des Adreßraums
</li><li>Reduzierung des Umfangs der Routing-Tabellen
</li><li>Vereinfachung des Protokolls, damit die Router Pakete schneller abwickeln können
</li><li>Höhere Sicherheit (Authentifikation und Datenschutz) als das heutige IP
</li><li>Mehr Gewicht auf Dienstarten, insbesondere für Echtzeitanwendungen
</li><li>Unterstützung von Multicasting durch die Möglichkeit, den Umfang zu definieren
</li><li>Möglichkeit für Hosts, ohne Adreßänderung auf Reise zu gehen (Laptop)
</li><li>Möglichkeit für das Protokoll, sich zukünftig weiterzuentwickeln
</li><li>Unterstützung der alten und neuen Protokolle in Koexistenz für Jahre
</li></ul>
Im Dezember 1993 forderte die IETF mit RFC 1550 die Internet-Gemeinde dazu auf, 
Vorschläge für ein neues Internet Protokoll zu machen. Auf die Anfrage
wurde eine Vielzahl von Vorschlägen eingereicht. Diese reichten von nur 
geringfügigen Änderungen am bestehenden IPv4 bis zur vollständigen 
Ablösung durch ein neues Protokoll. Aus diesen Vorschlägen wurde von der 
IETF das <i>Simple Internet Protocol Plus (SIPP)</i> als Grundlage für die neue 
IP-Version ausgewählt.
<p>
Als die Entwickler mit den Arbeiten an der neuen Version des Internet Protokolls begannen, 
wurde ein Name für das Projekt bzw. das neue Protokoll benötigt. Angeregt durch 
die Fernsehserie "Star Trek - Next Generation", wurde als Arbeitsname <i>IP - Next 
Generation (IPnG)</i> gewählt. Schließlich bekam das neue IP eine offizielle 
Versionsnummer zugewiesen: IP Version 6 oder kurz IPv6. Die Protokollnummer 5 (IPv5)
wurde bereits für ein experimentelles Protokoll verwendet.
</p><p>

</p><h3>Die Merkmale von IPv6</h3>
Viele der Merkmale von IPv4 bleiben in IPv6 erhalten. Trotzdem ist IPv6 im allgemeinen 
nicht mit IPv4 kompatibel, wohl aber zu den darüberliegenden Internet-Protokollen, 
insbesondere den Protokollen der Transportschicht (TCP, UDP). Die wesentlichen Merkmale 
von IPv6 sind:
<ul>
<li><b>Adreßgröße:</b> Statt bisher 32 Bit stehen nun 128 Bit 
für die Adressen bereit. Theoretisch lassen sich damit 2<sup>128</sup>
= 3.4*10<sup>38</sup> Adressen vergeben.
</li><li><b>Header-Format:</b> Der IPv6-Header wurde vollständig geändert. Der 
Header enthält nur sieben statt bisher 13 Felder. Diese Änderung ermöglicht 
die schneller Verarbeitung der Pakete im Router. Im Gegensatz zu IPv4 gibt es bei IPv6 
nicht mehr nur einen Header, sondern mehrere Header. Ein Datengramm besteht
aus einem Basis-Header, sowie einem oder mehreren Zusatz-Headern, gefolgt von den Nutzdaten.
<p>
<img src="TCP_IP-Dateien/ipv6dgram.gif">
</p><p>
</p></li><li><b>Erweiterte Unterstützung von Optionen und Erweiterungen:</b> Die Erweiterung 
der Optionen ist notwendig geworden, da einige der bei IPv4 notwendige Felder nun optional 
sind. Darüber hinaus unterscheidet sich auch die Art, wie die Optionen dargestellt 
werden. Für Router wird es damit einfacher, Optionen, die nicht für
sie bestimmt sind, zu überspringen. 
</li><li><b>Dienstarten:</b> IPv6 legt mehr Gewicht auf die Unterstützung von 
Dienstarten. Damit kommt IPv6 den Forderungen nach einer verbesserten Unterstützung 
der Übertragung von Video- und Audiodaten entgegen, z. B. durch eine Option zur 
Echtzeitübertragung.
</li><li><b>Sicherheit:</b> IPv6 beinhaltet nun im Protokoll selbst Mechanismen zur sicheren 
Datenübertragung. Wichtige neue Merkmale von IPv6 sind hier Authentifikation,
Datenintegrität und Datenverlässlichkeit.
</li><li><b>Erweiterbarkeit:</b> IPv6 ist ein erweiterbares Protokoll. Bei der Spezifikation 
des Protokolls wurde nicht versucht, alle möglichen Einsatzfelder für das 
Protokoll in die Spezifikation zu integrieren. Über Erweiterungs-Header kann das
Protokoll erweitert werden. 
</li></ul>
<p>

</p><h3>Aufbau des IPv6-Basis-Headers</h3>
Im IPv6 wird im Vergleich zum IPv4 auf eine Checksumme verzichtet, 
um den Routern die aufwendige Überprüfung - und damit Rechenzeit 
- zu ersparen. Ein Übertragungsfehler muss deshalb in den höheren
Schichten erkannt werden. Der Paketkopf ist durch die Verschlankung 
nur doppelt so groß, wie ein IPv4-Header.
<p>
</p><center><img src="TCP_IP-Dateien/ipv6mainheader.gif"></center>
<p>
</p><dl>
<dt><b>Version:</b></dt>
<dd>
Mit dem Feld <i>Version</i> können Router überprüfen, um welche 
Version des Protokolls es sich handelt. Für ein IPv6-Datengramm ist dieses Feld 
immer 6 und für ein IPv4-Datengramm dementsprechend immer 4. Mit diesem Feld 
ist es möglich für eine lange Zeit die unterschiedlichen Protokollversionen
IPv4 und IPv6 nebeneinander zu verwenden. Über die Prüfung des Feldes 
Version können die Daten an das jeweils richtige "Verarbeitungsprogramm" 
weitergeleitet werden.
</dd><dt><b>Priority:</b></dt>
<dd>
Durch das Feld <i>Priority</i> (oder <i>Traffic Class</i>) kann angegeben 
werden, ob ein Paket bevorzugt behandelt werden muß. Dies ist für die 
Anpassung des Protokolls an die neuen Real Time Anwendungen nötig geworden. 
Damit können zum Beispiel Videodaten den E-Maildaten vorgezogen werden. Bei 
einem Router unter Last besteht damit die Möglichkeit der Flusskontrolle. 
Pakete mit kleinerer Priorität werden verworfen und müssen wiederholt 
werden.Mit den vier Bit lassen sich 16 Prioritäten angeben, wovon 
1 bis 7 für "Non Real Time"- und 8 bis 15 für "Real Time"-Anwendungen 
reserviert sind. Die Zahl Null gibt an, dass die Priorität des 
Verkehrs nicht charakterisiert ist. 
</dd><dt><b>Flow Label</b></dt>
<dd>
Mit Hilfe des Feldes <i>Flow Label</i> können Eigenschaften des Datenflusses 
zwischen Sender und Empfänger definiert werden. Das Flow 
Label selbst ist nur eine Zufallszahl. Die Eigenschaften müssen 
durch spezielle Protokolle oder durch den Hop-by-Hop-Header in den Routern 
eingestellt werden. Eine Anwendung ist zum Beispiel, daß die Pakete eines 
Flusses immer den gleichen Weg im Netz nehmen. Durch Speichern der Informationen 
für das jeweilige Flow-Label, muß der Router bestimmte Berechnungen nur 
für das erste Paket ausführen, und kann danach für alle Folgepakete 
die Resultate verwenden. Erst die Einführung des Flow Labels ermöglicht 
die Einführung von Quality-of-Service-Parametern im IP-Verkehr.
</dd><dt><b>Payload Length</b></dt>
<dd>
Das Feld <i>Payload Length (Nutzdatenlänge)</i> gibt an, wie viele Bytes 
dem IPv6-Basis-Header folgen, der IPv6-Basis-Header ist ausgeschlossen. Die 
Erweiterungs-Header werden bei der Berechnung der Nutzdatenlänge mit einbezogen. 
Das entsprechende Feld wird in der Protokollversion 4 mit <i>Total Length</i> bezeichnet. 
Allerdings bezieht IPv4 den 20 Byte großen Header auch in die Berechnung ein, 
wodurch die Bezeichnung "total length" gerechtfertigt ist.
</dd><dt><b>Next Header</b></dt>
<dd>
Das Feld <i>Next Header</i> gibt an, welcher Erweiterungs-Header dem IPv6-Basis-Header 
folgt. Jeder folgende Erweiterungs-Header beinhaltet ebenfalls ein Feld Next Header, das 
auf den nachfolgenden Header verweist. Beim letzten IPv6-Header, gibt das Feld an, welches 
Transportprotokoll (z.B. TCP oder UDP) folgt.
</dd><dt><b>Hop Limit</b></dt>
<dd>
Im Feld <i>Hop Limit</i> wird festgelegt, wie lange ein Paket überleben darf. 
Der Wert des Feldes wird von jedem Router vermindert. Ein Datengramm wird verworfen, 
wenn das Feld den Wert Null hat. IPv4 verwendete hierzu das Feld <i>Time to Live</i>.
Die Bezeichnung bringt mehr Klarheit, da schon in IPv4 die Anzahl Hops gezählt 
und nicht die Zeit gemessen wurde.
</dd><dt><b>Source Address, Destination Address</b></dt>
<dd>
Die beiden Felder für <i>Quell-</i> und <i>Zieladresse</i> dienen zur 
Identifizierung des Senders und Empfängers eines IP-Datengramms. Bei IPv6 sind
die Adressen vier mal so groß wie IPv4: 128 Bit statt 32 Bit. 
</dd></dl>
<p>
Das Feld <i>Length (Internet Header Length - IHL)</i> von IPv4 ist nicht
mehr vorhanden, da der IPv6-Basis-Header eine feste Länge von 40 Byte hat. 
Das Feld <i>Protocol</i> wird durch das Feld <i>Next Header</i> ersetzt.
Alle Felder die bisher zur Fragmentierung eines IP-Datengramms benötigt wurden 
(<i>Identification, Flags, Fragment Offset</i>), sind im IPv6-Basis-Header nicht 
mehr vorhanden, da die Fragmentierung in IPv6 gegenüber IPv4 anders gehandhabt
wird. Alle IPv6-kompatiblen Hosts und Router müssen Pakete mit einer Größe 
von 1280 Byte unterstützen. Empfängt ein Router ein zu großes Paket, so
führt er keine Fragmentierung mehr durch, sondern sendet eine Nachricht an den 
Absender des Pakets zurück, in der er den sendenden Host anweist, alle weiteren 
Pakete zu diesem Ziel aufzuteilen. Es wird also vom Hosts erwartet, daß er 
von vornherein eine passende Paketgröße wählt. Die Steuerung der 
Fragmentierung erfolgt bei IPv6 über den <i>Fragment Header</i>.
Das Feld <i>Checksum</i> ist nicht mehr vorhanden.
</p><p>

</p><h3>Erweiterungs-Header im IPv6</h3>
Bei IPv6 muß nicht mehr der ganze optionale Teil des Headers von allen Routern 
verarbeitet werden, womit wiederum Rechenzeit eingespart werden kann. Diese 
optionalen Header werden miteinander verkettet. Jeder optionale Header beinhaltet 
die Identifikation des folgenden Header. Es besteht auch die Möglichkeit 
selber Optionen zu definieren. 
<p>
Derzeit sind sechs Erweiterungs-Header definiert. Alle Erweiterungs-Header sind optional. 
Werden mehrere Erweiterungs-Header verwendet, so ist es erforderlich, sie in einer 
festen Reihenfolge anzugeben.
</p><p>
</p><center>
<table align="CENTER" width="80%" border="1" cellpadding="4">
<tbody><tr>
<th>Header
</th><th>Beschreibung
</th></tr>
<tr>
<td valign="TOP">IPv6-Basis-Header</td>
<td valign="TOP">Zwingend erforderlicher IPv6-Basis-Header</td>
</tr>
<tr>
<td valign="TOP">Optionen für Teilstrecken<br>
(Hop-by-Hop Options Header)</td>
<td valign="TOP">Dies ist der einzige optionale Header, der von jedem Router bearbeitet 
werden muß. Bis jetzt ist nur die "Jumbo Payload Option" definiert, in der die 
Länge eines Paketes angegeben werden kann, das länger als 64 KByte ist.
</td>
</tr>
<tr>
<td valign="TOP">Optionen für Ziele<br>
(Destination Options Header)</td>
<td valign="TOP">Zusätzliche Informationen für das Ziel</td>
</tr>
<tr>
<td valign="TOP">Routing<br>
(Routing Header)</td>
<td valign="TOP">Definition einer vollständigen oder teilweisen Route.
Er wird für das Source-Routing in IPv6 verwendet.</td>
</tr>
<tr>
<td valign="TOP">Fragmentierung<br>
(Fragment Header)</td>
<td valign="TOP">In IPv6 wird, wie oben beschrieben, die Fragmentierung nur 
noch End to End gemacht. Die Fragmentierinformationen werden in diesem 
optionalen Header abgelegt.
</td>
</tr>
<tr>
<td valign="TOP">Authentifikation<br>
(Authentication Header)</td>
<td valign="TOP">Er dient der digitalen Signatur von Paketen, um die Quelle eindeutig 
feststellen zu können.
</td>
</tr>
<tr>
<td valign="TOP">Verschlüsselte Sicherheitsdaten<br>
(Encapsulating Security Payload Header)</td>
<td valign="TOP">Informationen über den verschlüsselten Inhalt.</td>
</tr>
<tr>
<td valign="TOP">Optionen für Ziele<br>
(Destination Options Header)</td>
<td valign="TOP">Zusätzliche Informationen für das Ziel (für 
Optionen, die nur vom endgültigen Ziel des Paketes verarbeitet werden 
müssen).</td>
</tr>
<tr>
<td valign="TOP">Header der höheren Schichten<br>
(Upper Layer Header)</td>
<td valign="TOP">Header der höheren Protokollschichten (TCP, UDP, ...)</td>
</tr>
</tbody></table>
</center>
<p>

</p><h3>IPv6-Adressen</h3>
Die IPv6-Adressen sind zwar von 32 Bit auf 128 Bit angewachsen, trotzdem sind die 
grundsätzlichen Konzepte gleich geblieben. Die Adresse wird normalerweise
Sedezimal (Hexadezimal, Basis 16) notiert und hat die allgemeine Form 
<pre>  xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx 
</pre>
Sie ist damit recht länglich. Um die Schreibweise zu vereinfachen, 
wurden einige Regeln eingeführt:
<ul>
<li>Führende Nullen<br>
Die führenden Nullen können mit Nullen oder Doppelpunkten 
zusammengefasst werden.
<pre>1234:0000:0000:0000:0000:0000:0000:1234 
                  --&gt;
         1234:0:0:0:0:0:0:1234
                  --&gt; 
               1234::1234
</pre>
<p>
</p></li><li>IPv4 kompatible Adressen haben die Form:
<pre>0:0:0:0:0:0:C206:AFFE
      oder 
::C206:AFFE
</pre>
Um die Lesbarkeit zu erhöhen kann man auch eine gemischt Form verwenden:
<pre>::194.6.161.126
</pre>
<p>
</p></li><li>IPv4 gemappte IPv6 Adressen haben die Form:
<pre>::FFFF:C206:A17E
</pre>
</li><li>Die Loopback Adresse ist neu (anstelle 127.0.0.1):
<pre>::1 
</pre>
</li></ul>
<p>

In IPv4 wurden die Adressen anfänglich in die bekannten Klassen eingeteilt. 
Ein weiteres Problem bei den IPv4 Adressen ist, daß die Router keine 
Hierarchie in den Adressen erkennen können. Auch IPv6 ist in der allgemeinen 
Form unstrukturiert, es kann aber durch definierte Präfixe strukturiert werden. 
Die allgemein strukturiert Adresse sieht danach wie folgt aus:
</p><p>
</p><center><img src="TCP_IP-Dateien/ipv6strukt.gif"></center>
<p>
Die Strukturierung erlaubt die Einteilung der Adresse in Adresstypen. Jeder Präfix 
identifiziert somit einen Adresstyp. Die bereits definierten Adresstypen und die 
zugehörigen Präfixe sind:
</p><p>
</p><center>
<table border="1" cellpadding="4">
<tbody><tr><th>Adresstyp</th><th>Präfix (binär)</th></tr>
<tr> 
<td valign="TOP">Reserviert für IPv4 und Loopback</td><td align="right" valign="TOP">0000 0000</td></tr>
<tr><td valign="TOP"> NSAP-Adressen </td><td align="right" valign="TOP"> 0000 001 </td></tr>
<tr><td valign="TOP"> IPX-Adressen </td><td align="right" valign="TOP"> 0000 010 </td></tr>
<tr><td valign="TOP"> Anbieterbasierte Unicast-Adresse </td><td align="right" valign="TOP"> 010 </td></tr>
<tr><td valign="TOP"> Reserviert für geografische Unicast-Adresse </td><td align="right" valign="TOP"> 100 </td></tr>
<tr><td valign="TOP"> Zusammenfassbare globale Adressen </td><td align="right" valign="TOP"> 001 </td></tr>
<tr><td valign="TOP"> Standortlokale Adresse </td><td align="right" valign="TOP"> 1111 1110 11 </td></tr>
<tr><td valign="TOP"> Multicast-Adresse </td><td align="right" valign="TOP"> 1111 1111 </td></tr>
</tbody></table>
</center>
<p> 
Wie man in der Tabelle erkennen kann, werden die Adressen grob in die Typen 
<i>Unicast</i>, <i>Multicast</i> und <i>Anycast</i> eingeteilt, deren Eigenschaften 
nachfolgend kurz erklärt werden sollen.
</p><ul>
<li><i>Unicast</i><br>
Als Unicast-Adressen bezeichnet man die Adressen, die für Punkt-zu-Punkt-Verbindungen 
verwendet werden. Sie werden in verschiedene Gruppen eingeteilt:
  <ul>
  <li>Geographisch basierte Unicast-Adresse<br>
  Für diese Adressen wurde erst der Adressbereich und der Präfix 
  reserviert. Die Idee ist, dass ein hierarchisches Routing aufgrund der 
  geographischen Lage - ähnlich wie beim Telefon - möglich sein 
  soll.
  </li><li>Anbieterbasierte Unicast-Adressen<br>
  Dieser Adresstyp erlaubt ein hierarchisches Routing aufgrund der Adressräume 
  der Anbieter. Diese Adressen werden von einem Register über ein großes 
  Gebiet verwaltet. Diese Register geben die Adressen an die Anbieter weiter, 
  welche ihrerseits Adressen weitergeben können. Somit ergibt sich 
  eine Adress-Struktur, die wie folgt aussieht:
  <p>
  <img src="TCP_IP-Dateien/ipv6unicast.gif">
  </p><p>
  Die Einführung von nationalen Registern ergibt eine Aufteilung 
  der Anbieter- und Subscriber-ID in National-Register-, Anbieter- und 
  Subscriber-ID.
  </p></li></ul>
</li><li><i>Linklokale und standortlokale Adressen</i><br>
Diese Adressen werden für die TCP/IP-Dienste innerhalb eines Unternehmens 
genutzt. Die Linklokalen Adressen werden nicht in das Internet geroutet und haben 
den folgenden Aufbau:
<p>
<img src="TCP_IP-Dateien/ipv6loc1.gif">
</p><p> 
Im Gegensatz dazu stehen die standortlokalen Adressen, die nur innerhalb eines 
Subnetzes gültig sind und deshalb von keinem Router behandelt werden.
</p><p>
<img src="TCP_IP-Dateien/ipv6loc2.gif">
</p><p>
</p></li><li><i>Multicast-Adressen</i><br>
In IPv4 wird das Rundsenden eines Paketes an mehrere Stationen durch das IGMP 
(Internet Group Management Protokoll) realisiert. In IPv6 ist das Prinzip 
übernommen, aber ein eigener Adresstyp definiert worden. IGMP entfällt 
somit gänzlich. Das Paket für Multicast-Meldungen sieht wie folgt aus:
<p>
<img src="TCP_IP-Dateien/ipv6multicast.gif">
</p><p>
Das Flag gibt an, ob die Gruppen ID temporär, oder von der IANA 
zugewiesen ist. Der Scope gibt den Gültigkeitsbereich der Multicast 
Adresse an. Dieser reicht vom nodelokalen bis zum globalen Bereich.
</p></li><li><i>Anycast Adressen</i><br>
Diese Adressen sind neu definiert worden. es können mehrere Rechner zu einer 
Gruppe zusammengefasst werden und sie sind dann unter einer einzigen Adresse erreichbar.
Damit ist beispielsweise eine Lastverteilung möglich: der Rechner, der am wenigsten 
belastet ist, behandelt das Paket. Die Adresse hat die folgende Struktur:
<p>
<img src="TCP_IP-Dateien/ipv6anycast.gif">
</p><p>
</p></li></ul>

<h3>Sicherheit</h3>
Der Bedarf an digitalen Unterschriften oder elektronischen Zahlungsmöglichkeiten
steigt ständig. Deshalb stand bei der Spezifikation von IPv6 die Sicherheit von 
Anfang an im Mittelpunkt. Für die Sicherheitsfunktionen von IPv6 ist eine 
spezielle Arbeitsgruppe "IPSec" zuständig.<br>
In IPv6 wurden Sicherheitsmechanismen für die Authentisierung und Verschlüsselung 
auf IP Ebene spezifiziert. Die Verschlüsselungsfunktionen definieren Verfahren, 
die das Mitlesen durch Unbefugte verhindern. Es gibt zwei unterschiedliche Ansätze. 
Bei der ersten Variante werden alle Nutzdaten (Payload) verschlüsselt. Der Header 
bleibt normal lesbar. Bei der anderen Variante ist es möglich, den Header 
ebenfalls zu verschlüsseln. Das codierte Paket wird in ein anderes IPv6-Packet 
verpackt und zu einem fixen Ziel befördert ("IP-Tunnel"). Am Ziel wird das Paket 
wieder entschlüsselt und über das sichere interne Netz übertragen. 
<p>
Authentisierungsmechanismen liefern den Beweis auf Unverfälschtheit 
der Nachricht und identifiziert den Absender (Digitale Unterschrift). 
Hier werden verschiedene kryptographische Verfahren eingesetzt.
Die Verfahren für die Verschlüsselung und die Authentisierung 
können auch getrennt angewandt werden.
Verwaltung und Verteilung der Schlüssel wird nicht von IPv6 gelöst. 
Das Standardverfahren für den IPv6-Authentisierungsmechanismus 
ist MD5 mit 128 Bit langen Schlüsseln. IPv6 schreibt keinen 
Verschlüsselungsmechanismus vor, jedes System im Internet 
muß jedoch den DES mit CBD (Cipher Block Chaining) unterstützen.
</p><p>

</p><h2><a name="8.9">Domain Name System (DNS)</a></h2>
Es hat sich ziemlich früh herausgestellt, daß menschliche
Benutzer die numerischen IP-Adressen nicht benutzen wollen,
sondern aussagekräftige und vor allem merkbare Namen
bevorzugen. Außerdem ist es ein großer Nachteil der IP-
Adressen, daß aus ihnen keinerlei geographische Information
zu entnehmen ist. Man sieht einer Zieladresse nicht an, ob
sie in Australien oder im Nebenzimmer lokalisiert ist,
außer man kennt zufällig die gewählten Zahlen. Es wurde
daher das Domain Name System entwickelt, das den Aufbau von
Rechnernamen regelt. Es ordnet jedem (weltweit eindeutigen)
Namen eine IP-Adresse zu. Dabei gibt es einige Varianten.
Eine Maschine mit einer IP-Adresse kann mehrere Funktionen
haben und daher auch mehrere Namen, die auf diese
Funktionen hinweisen. Genauso kann eine Maschine (z. B. ein
Router) viele IP-Adressen haben aber nur einen Namen.
<p>
Beim "Domain-Name-System"  (oder kurz: DNS) handelt es sich um einen
Dienst, der zu einem Rechnernamen die zugehörige IP-Nummer
liefert und umgekehrt. Das ist in etwa mit der Funktionsweise
einer Telefonauskunft vergleichbar:
Der Kunde ruft bei einer bestimmten Telefonnummer an und fragt
nach der Rufnummer eines Teilnehmers. Nachdem er Name und Wohnort
der gesuchten Person durchgegeben hat, erhält er als Antwort die gewünschte
Nummer aus einem Verzeichnis. Genauso läuft eine DNS-Abfrage ab.
</p><center>
<p>
<img src="TCP_IP-Dateien/auskunft.gif">
</p><p>
</p></center>
Gibt ein Benutzer in seinem Webbrowser zum Beispiel die Adresse
<p>
<tt>
http://www.VereinGegenZuLangeDomainnamenEV.de
</tt>
</p><p>

ein, dann sorgt ein Teil der Netzwerk-Software
auf seinem lokalen Rechner dafür, daß ein Name-Server nach der IP-Adresse
des Rechners <tt>www.vereingegenzulangedomainnamenev.de</tt> gefragt wird.
Dieser Softwareteil wird als <i> Resolver</i> bezeichnet und entspricht in
obigem Beispiel dem Kunden, der die Auskunft anruft.
Welche IP-Adresse dieser Server hat, muß dem Klientenrechner natürlich
bekannt sein, genauso wie der Kunde eine einzige Telefonnummer wissen muß,
nämlich die der Auskunft selbst.

Auf der Serverseite arbeitet eine Software, die als <i>"Domain-Name-Server"</i> oder 
kurz <i>"Name-Server"</i> bezeichnet wird und anhand einer Datenbank
(<i>"Zone-File"</i>) die passende IP-Nummer zum Rechnernamen liefert, oder
einen anderen Name-Server fragt, wenn die Adresse unbekannt ist.
</p><center>
<p>
<img src="TCP_IP-Dateien/dns-simple.gif">
</p><p>
</p></center>

DNS ist ein typisches Beispiel für einen Verzeichnisdienst. Seine Aufgaben sind:

<ul>
  <li>Strukturierung der Namen. (Domänen-Konzept)
  </li><li>Zuteilung und Verwaltung von Namen.
  </li><li>Auflösen von Namen (="Nachschlagen") in beide Richtungen (Name zu Adresse und Adresse zu Name)
  </li><li>Zwischenspeichern von Adressen (Caching)
  </li><li>Einteilung der Daten in hierarchische Ebenen
  </li><li>Verteilung der Daten auf verschiedene Knoten
  </li><li>Bereitstellung von Redundanz (Secondary-DNS, Caching-Only-Server)
</li></ul>
Damit das DNS funktioniert muß es Instanzen geben, die
Namen in IP-Adressen und IP-Adressen in Namen umwandeln
('auflösen') können. Diese Instanzen sind durch Programme
realisiert, die an größeren Maschinen ständig (meist im
Hintergrund) im Betrieb sind und 'Nameserver' heißen. Jeder Rechner, der an das
Internet angeschlossen wird, muß die Adresse eines oder
mehrerer Nameserver wissen, damit die Anwendungen auf
diesem Rechner mit Namen benutzt werden können. Die
Nameserver sind für bestimmte Bereiche, sogenannte
'domains' oder 'Zonen', zuständig (Institute, Organisationen, Regionen)
und haben Kontakt zu anderen Nameservern, so daß jeder Name
aufgelöst werden kann.
<p>

</p><h3>Domänen-Konzept</h3>
In den Anfängen des ARPA-Nets, aus  dem das Internet entstand, wurde die 
Namensauflösung über eine einzige Datei erledigt. Jeder Rechner 
kopierte sich Nachts per FTP diese Datei von einem  Master-Server auf die 
lokale Platte. Dieses Konzept funktioniert natürlich nur, solange die
Anzahl der Namen nicht groß ist. Die benötigte Bandbreite ist proportinal 
zum Quadrat der beteiligten Rechner. 
<p>
B ~ N<sup>2</sup>
</p><p>
Als Relikt aus dieser Zeit kennt fast jedes Betriebssystem auch heute noch eine 
Hosts-Datei, in der für kleine Netze Rechner/Nummern-Zuordnungen 
abgelegt werden könen. (Bei Windows im Verzeichnis <tt>\WINDOWS\HOSTS</tt>, 
bei Unix unter <tt>/etc/hosts</tt>, bei Novell unter 
<tt>SYS:SYSTEM/ETC/HOSTS</tt>, etc.)

Die Syntax aller dieser Hosts-Dateien ist einfach. Für jeden Rechner gibt 
es eine eigene Zeile mit dem Inhalt:
</p><pre>IP-Nummer	Hostname Alias Alias ....
</pre>
Zum Beispiel:
<pre>192.168.112.1    chef dumpfbacke  
192.168.112.2    Snow-White
192.168.112.3    Doc
192.168.112.4    Happy
192.168.112.5    Bashful
192.168.112.6    Sneezy
192.168.112.7    Sleepy
192.168.112.7    Grumpy
192.168.112.8    Dopey
</pre>
Der Begriff <i>Alias</i> läßt sich dabei am besten durch <i>"Spitzname"</i>
(oder englisch <i>Nickname</i>) ersetzen; also ein weiterer Name für ein und den 
selben Rechner.
<p>
Bei einer kleinen Menge von Rechnern ist die Namensverwaltung mit einer Datei noch 
möglich; für einen so großen und ständig wechselnden Verbund wie 
das Internet ist sie aber nicht geeignet. Hier ist eine dezentrale Verwaltung mit 
einem eigens darauf abgestimmten Namensraum nötig.
</p><p>
Der Namensraum des DNS ist in sogenannte Domänen eingeteilt. Die Domänen sind
hierarchisch als Baum angeordnet,

</p><p>
</p><center>
<img src="TCP_IP-Dateien/dns-baum.gif">
</center>
<p>
Ausgehend von der Wurzel (=<i>Root</i>) des Baumes ist der Namensraum in sogenannte
"<i>Toplevel-Domains</i>" eingeteilt. Man unterscheidet dabei zwischen zwei verschiedenen
Klassen von Toplevel-Domänen: Den generischen und den länderspezifischen.
</p><p>
</p><center>
<table border="1" cellpadding="5">
<tbody><tr><th colspan="2">Toplevel-Domänen</th></tr>
<tr><th valign="top">generisch </th>
<td>
<table border="0" cellpadding="5" cellspacing="0" width="80%">
<tbody><tr><td width="20%">com</td><td>Kommerzielle Organisationen</td></tr>
<tr><td>edu</td><td>(education) Schulen und Hochschulen</td></tr>
<tr><td>gov</td><td>(government) Regierungsinstitutionen</td></tr>
<tr><td>mil</td><td>militärische Einrichtungen</td></tr>
<tr><td>net</td><td>Netzwerk betreffende Organisationen</td></tr>
<tr><td>org</td><td>Nichtkommerzielle Organisationen</td></tr>
<tr><td>int</td><td>Internationale Organisationen</td></tr>
<tr><td><p>arpa</p></td><td>und das alte ARPA-Net bzw. Rückwärts-Auflösung
von Adressen</td></tr>
</tbody></table>
<p>
Ende 2000 sind neue TLDs von der ICANN genehmigt worden:
</p><p>
<table border="0" cellpadding="5" cellspacing="0" width="70%">
<tbody><tr><td width="20%">aero</td><td>Luftfahrtindustrie</td></tr>
<tr><td>coop</td><td>Firmen-Kooperationen</td></tr>
<tr><td>museum</td><td>Museen</td></tr>
<tr><td>pro</td><td>Ärzte, Rechtsanwälte und andere Freiberufler</td></tr>
<tr><td>biz</td><td>Business (frei für alle)</td></tr>
<tr><td>info</td><td>Informationsanbieter (frei für alle)</td></tr>
<tr><td>name</td><td>Private Homepages (frei für alle, aber nur
dreistufige Domains der Form &lt;Vorname&gt;.&lt;Name&gt;.name)</td></tr>
</tbody></table>
</p></td></tr>
<tr>
<th valign="top">länderspezifisch</th>
<td>Jeweils ein Länderkürzel für jedes Land, z.B.:<br>
<table border="0" cellpadding="5" cellspacing="0" width="70%">
<tbody><tr><td width="20%">by</td><td>Weissrussland</td></tr>
<tr><td>de</td><td>Deutschland</td></tr>
<tr><td>at</td><td>Östereich</td></tr>
<tr><td>fr</td><td>Frankreich</td></tr>
<tr><td>to</td><td>Tonga</td></tr>
<tr><td>tv</td><td>Tuvalu</td></tr>
</tbody></table>
</td>
</tr>
</tbody></table>
</center>
<p>
</p><center>
<img src="TCP_IP-Dateien/tonga.gif">
</center>

<p>
Unterhalb der Toplevel-Domänen folgen Subdomänen, die wiederum Domänen 
enthalten könen und schliesslich, als Blatt des Baumes, ein einzelner Rechner. 
Der Name <tt>www.netzmafia.de</tt> ist also so zu verstehen. In der Toplevel-Domäne 
<i>".de"</i> ist die Subdomain "<i>Netzmafia</i>" bekannt. Innerhalb der Subdomain 
"<i>netzmafia</i>" gibt es einen Rechner namens "<i>www</i>". Analog zu unserem
Beispiel mit der Telefonauskunft, ist mit "de" das Land, mit "netzmafia" der Ort und 
die Straße und mit "www" der Name eines Teilnehmers bestimmt. Die komplette Adresse 
eines Rechners in der beschriebenen Notation, z.B. bezeichnet man (www.netzmafia.de) 
als FQDN (<i>Full-Qualified-Domain-Name</i>).
</p><p>
Für die Aufnahme einer Verbindung zwischen zwei Rechnern
muß in jedem Fall der Rechnername in eine zugehörige IP-
Adresse umgewandelt werden. Aus Sicherheitsaspekten ist es
manchmal wünschenswert, auch den umgekehrten Weg zu gehen,
nämlich zu einer sich meldenden Adresse den Namen und damit
die organisatorische Zugehörigkeit offenzulegen.
</p><p>

</p><h4>Komponenten des DNS</h4>
Insgesamt sind es drei Hauptkomponenten, aus denen sich das DNS zusammensetzt:
<ol>
<li> Der <b>Domain Name Space</b>, ein baumartig, hierarchisch strukturierter Namensraum 
und die Resource Records. Das sind Datensätze, die den Knoten zugeordnet sind.
</li><li> <b>Name Server</b> sind Programme bzw. Rechner, die die Informationen über die 
Struktur des Domain Name Space verwalten und aktualisieren. EinNameserver hat 
normalerweise nur eine Teilsicht des Domain Name Space zu verwalten. Oft wird
auch der Rechner, auf dem das Nameserverprogramm läuft, als 'Nameserver' oder
'DNS-Server' bezeichnet.
</li><li> <b>Resolver</b> sind die Programme, die für den Client Anfragen an den 
Nameserver stellen. Resolver sind einemNameserver zugeordnet; bei Anfragen, die er 
nicht  beantworten kann (anderer Teilbereich des Domain Name Space). kann er aufgrund 
von Referenzen andere Nameserver kontakten, um die Information zu erhalten.
</li></ol>
<p>
</p><center><img src="TCP_IP-Dateien/dns.gif"></center>
<p>

Der <b>Nameserver</b> des DNS verwaltet also einzelne Zonen, die einen Knoten im DNS-Baum
und alle darunterliegenden Zweige beinhalten. Auf jeder Ebene des DNS-Baums kann es 
Namesever geben, wobei jeder Nameserver seinen nächsthöheren und nächstniedrigeren Nachbarn
kennt. Aus Sicherheitsgründen gibt es für jede Zone in der Regel mindestens zwei Nameserver
(<i>primary</i> und <i>secondary</i>), wobei beide die gleiche Information halten.
Nameservereinträge können nicht nur die Zuordnung Rechnername - IP-Adresse enthalten, 
sondern (neben anderem) auch weitere Namenseinträge für einen einzigen Rechner und
Angaben für Postverwaltungsrechner einer Domain (MX, mail exchange).
</p><p>
Basis des Nameservice bilden die "Root-Nameserver", die für die Top-Level-Domains
zuständig sind. Federführende Organistation ist hier die ICANN 
(<i>=Internet Corporation for Assigned Names and Numbers </i>, 
Adresse: <a href="https://web.archive.org/web/20070611100850/http://www.icann.org/">http://www.icann.org</a>). Gründung 1998.
ICANN beauftragt die Verwalter der Zone "." (Wurzel des DNS-Baumes) mit 13 Servern.
Bis auf die Server I (Stockholm), K (London) und  M (Tokio) stehen alle
Server in den USA.
</p><p>
</p><center><img src="TCP_IP-Dateien/nameserver.gif"></center>
<p>
<table border="1" cellpadding="5" cellspacing="0" width="70%" align="center">
<tbody><tr><th>Name</th><th>Typ</th><th>Betreiber</th><th>URL</th></tr>
<tr><td>a</td><td>com</td><td>InterNic</td><td>http://www.internic.org</td></tr>
<tr><td>b</td><td>edu</td><td>ISI</td>     <td>http://www.isi.edu</td></tr>
<tr><td>c</td><td>com</td><td>PSINet</td>  <td>http://www.psi.net</td></tr>
<tr><td>d</td><td>edu</td><td>UMD</td>     <td>http://www.umd.edu</td></tr>
<tr><td>e</td><td>usg</td><td>NASA</td>    <td>http://www.nasa.gov</td></tr>
<tr><td>f</td><td>com</td><td>ISC</td>     <td>http://www.isc.org</td></tr>
<tr><td>g</td><td>usg</td><td>DISA</td>    <td>http://nic.mil</td></tr>
<tr><td>h</td><td>usg</td><td>ARL</td>     <td>http://www.arl.mil</td></tr>
<tr><td>i</td><td>int</td><td>NordUnet</td><td>http://www.nordu.net</td></tr>
<tr><td>j</td><td>( &nbsp; )</td> <td>(TBD)</td>   <td>http://www.iana.org</td></tr>
<tr><td>k</td><td>int</td><td>RIPE</td>    <td>http://www.ripe.net</td></tr>
<tr><td>l</td><td>( &nbsp; )</td> <td>(TBD)</td>   <td>http://www.iana.org</td></tr>
<tr><td>m</td><td>int</td><td>WIDE</td>    <td>http://www.wide.ad.jp</td></tr>
</tbody></table>
</p><p>
Der Server A ist der primäre Server, alle anderen sind seine Secondaries.
Eine Liste dieser Root-Server muss jeder DNS-Server haben (Ausnahme: Cache-Only-Server).
Erzeugung der Liste mit dem Kommando:
</p><pre>dig @rs.internic.net . ns &gt; root.servers
</pre>
<p>
Die Namen, die im Internet verwendet werden müssen dabei einige Spezifikationen 
erfüllen:
</p><ul>
<li>Die Länge eines Namensteiles (Domänen- oder Rechnername) darf maximal 
63 Zeichen betragen.
</li><li> Die Gesamtlänge des Full-Qualified-Domain-Names darf 255 Zeichen nicht 
überschreiten.
</li><li>Nur Buchstaben, Ziffern und "-" sind in den Namen zugelassen. Dabei muss jeder 
Name mit einem Buchstaben oder einer Ziffer beginnen und enden. ("3bla-fasel" ist 
zulässig, "3bla-" aber nicht.)
</li><li>Zwischen Groß- und Kleinschreibung wird nicht unterschieden.
</li></ul>
Bei der Registrierung einer Domain unterhalb von ".de" gelten zusätzlich noch 
folgende Regeln:
<ul>
<li>Der Domainname muß mindestens 3 Zeichen haben. Insgesamt gibt es in ".de" 
noch 4 Domains mit nur 2 Buchstaben, die aus Besitzstands-Gründen beibehalten werden.
</li><li>Wegen eines weit verbreiteten Fehlers in der Named-Server-Software sind Domains 
mit den gleichen Namen wie Toplevel-Einträge verboten. (Also z.B.: "at.de") Das ist 
in RFC 1535 näher beschrieben.
</li><li>KFZ-Kennzeichen können nicht registriert werden.
</li></ul>
<p>
</p><center>
<img src="TCP_IP-Dateien/domains_simple.gif">
</center>
<p>
Ein wichtiger Bestandteil des DNS-Konzeptes ist die Aufteilung der benötigten Datenbank
auf viele verschiedene Rechner. Da das Gesamtsystem voll funktionsfähig bleiben 
muß, auch wenn ein Server ausgefallen ist, wird die Datenhaltung mit Hilfe von 
Zuständigkeiten gelöst: Zu jeder Domain gibt es mindestens einen zugehörigen 
Server, der verantwortlich die darin enthaltenen Subdomains oder Rechner verwaltet, oder 
die Verwaltung an einen weiteren Server weiterdelegiert. Am Stamm des DNS-Baumes sitzen 
dazu die "<i>Root-Server</i>", die alle Einträge ihrer jeweiligen Domain kennen. 
Das heißt, daß der Root-Nameserver der Domäne ".de" einen Eintrag für 
den Named-Server der Domain "netzmafia.de" besitzt. Dieser Server hat wieder eine Liste 
der in "netzmafia.de" enthaltenen Rechner und Subdomains.
</p><p>
Die Frage eines Clients nach der IP-Nummern eines Rechners wird wie folgt abgewickelt:

</p><p>
</p><center>
<img src="TCP_IP-Dateien/dns-ablauf.gif">
</center>
<p>

</p><ol>
<li>Der Client-Rechner "grumpy.zwerge.org" stellt die DNS-Anfrage nach 
"www.netzmafia.de" an seinen zuständigen DNS-Server. Dessen IP-Nummer 
muss dem Client bekannt sein.
</li><li>Kennt der Nameserver der Domain "zwerge.org" die Antwort nicht,
 so erkundigt er sich beim Root-Nameserver nach der Adresse des 
Nameservers von ".de"
</li><li>Der Root-Nameserver antwortet dem zuständigen DNS-Server der Domain "zwerge.org" mit der Adresse des Nameservers von ".de"
</li><li>Der Nameserver der Domain "zwerge.org" erkundigt sich beim 
Nameserver von ".de" nach der Adresse des Nameservers von 
"netzmafia.de".
</li><li>Der Nameserver von ".de" antwortet dem zuständigen DNS-Server 
der Domain "zwerge.org" mit der Adresse des Nameservers von 
"netzmafia.de"
</li><li>Der Nameserver der Domain "zwerge.org" erkundigt sich beim 
Nameserver von "netzmafia.de" nach der Adresse des Rechners 
"www.netzmafia.de".
</li><li>Der Nameserver von "netzmafia.de" antwortet dem zuständigen 
DNS-Server der Domain "zwerge.org" mit der Adresse des Rechners von 
"www.netzmafia.de".
</li><li>Der DNS-Server von "zwerge.org" liefert die IP-Nummer an den anfragenden Client. Damit ist die DNS-Abfrage abgehandelt. 
</li></ol>
<p>

</p><h3>DNS-Typen</h3>

Man unterscheidet folgende DNS-Typen
<ul>
<li>Cache-Only
  <ul>
    <li>Besitzt keine eigenen Tabellen mit Rechnernamen (Zone-Files).
    </li><li>Alle Anfragen werden an einen übergeordneten Server weitergegeben.
    </li><li>Adressen werden zwischengespeichert.
    </li><li>Zweck: Z.B. Entlastung einer Providerleitung
    </li><li>Sehr einfach einzurichten.
  </li></ul>
</li><li>Secondary-DNS
  <ul>
    <li>Besitzt eigene Tabellen, die er vom Primary-DNS kopiert.
    </li><li>Die Tabellen können aber nicht verändert werden.
    </li><li>Zweck: Lastteilung, Backup
    </li><li>Einfach einzurichten.
  </li></ul>
</li><li>Primary-DNS
  <ul>
    <li>Besitzt eigene Tabellen für eine oder mehrere Zonen.
    </li><li>Tabellen können lokal verändert werden.
    </li><li>Server ist "<i>authoritative</i>" für seine Zone.
    </li><li>Relativ hoher Aufwand für Einrichtung und Pflege.
  </li></ul>
</li></ul>
<p>


</p><h3>DNS Resource Records</h3>
Im Standardfall generiert ein DNS-Server seine interne Datenbank
aus einer Textdatei, der sogenannten "Zonen-Datei". Damit er 
funktioniert, müssen bestimmte Einträge korrekt eingetragen
worden sein. An dieser Stelle sollen nur ein paar grundlegende
Eigenschaften der wichtigsten Typen von Resource Records betrachtet
werden. Es gibt verschiedene Record-Typen:
<ul>
<li>SOA-Records (Source of Authority) enthalten die technischen Angaben für
die gesamte Zone sowie einige Steuerdaten für die Zusammenarbeit der 
Nameserver untereinander. SOA-Records sind weiter unten genauer erklärt.
</li><li>NS-Records (Name Server) verweisen auf die Nameserver, die für eine Zone
authoritativ sind. Auf den eigenen Namen zeigende NS-Records dienen der
Plausibilitätsprüfung; NS-Records für eine Subdomain weisen darauf
hin, dass die Informationen für die Subdomain auf einem anderen
Nameserver zu finden sind (Delegation).
</li><li>A-Records (Address) verknüpfen einen Domainnamen mit einer IP-Adresse.
Um IPv4- und IPv6-Adressen zu unterscheiden, wird seit einiger Zeit für
IPv4 der A-Record und für IPv6 der AAAA-Record verwendet.
</li><li>PTR-Records (Pointer) verknüpfen eine IP-Adresse "rückwärts" 
mit einem Domainnamen.
</li><li>CNAME-Records Canonical Name) definieren einen Domainnamen als Alias für 
einen anderen. Es gibt also für jedes System einen A-Record und ggf. noch beliebig
viele CNAME-Records.
</li><li>MX-Records (Mail Exchanger) definieren, bei welchen Rechnern Mail für eine
Domain eingeliefert werden soll. Auf diese Weise sind geneische Mailadressen wie
z.B. "plate@fhm.edu" möglich.
</li><li>TXT-Records (Text) enthalten beliebige alphanumerische Informationen zu
einem Domainnamen.
</li></ul>

<h4>Aufbau der Zonendatei</h4>
Beispiel des Primary DNS "<i>aella.serverzwerge.de</i>":
<pre>; Zonendatei fuer die Domaene serverzwerge.de
;
$TTL 1D
@       in      SOA     aella.serverzwerge.de.  dnsadmin.aella.serverzwerge.de. (
                2002051505        ; Seriennummer
                10800   ; Refresh : 3 Stunden
                3600    ; Retry   : 1 Stunde
                604800  ; Expire  : 1 Woche
                86400)  ; Min. TTL: 1 Tag
                NS              aella.serverzwerge.de.
                MX              10 aella.serverzwerge.de.
                MX              50 mail.irgendeinprovider.de.
 
aella           A       10.23.200.100
snowwhite       A       10.23.200.17
doc             A       10.23.200.18
happy           A       10.23.200.19
bashful         A       10.23.200.20
sneezy          A       10.23.200.21
sleepy          A       10.23.200.22
grumpy          A       10.23.200.23
dopey           A       10.23.200.24
                HINFO   "Hexium 7.5" "Linux"
 
beispiel        CNAME   aella
</pre>

<h4>Der SOA-Record</h4>
Jede Zone muss einen SOA-Record (Start of Authority) enthalten. Dort
sind wichtige Informationen über die Zone abgelegt. Hier ein Beispiel:
<p></p>
<pre>$TTL 1D
@       in      SOA     aella.serverzwerge.de.  dnsadmin.aella.serverzwerge.de. (
                2002051505        ; Seriennummer
                10800   ; Refresh : 3 Stunden
                3600    ; Retry   : 1 Stunde
                604800  ; Expire  : 1 Woche
                86400)  ; Min. TTL: 1 Tag
</pre>
Das Semikolon leitet Kommentare ein, die natürlich nicht vorhanden
sein müssen.
<ul>
<li>Das erste Feld im SOA-Record benennt den primary master server.
Dies ist der Server, der die endgültige Autorität über den Inhalt der
Zone ist. Dort ist das Zonefile selbst abgelegt.
</li><li>Das zweite Feld des SOA-Records nennt die Mailbox der für die Zone
verantwortlichen Person. Das @-Zeichen der E-Mail-Adresse  wird hier durch einen Punkt 
ersetzt. Links vom @ stehende Punkte müssen als \. notiert werden, um eine
eindeutige Zuordnung für den Punkt zu erreichen, der für den @ steht.
</li><li>Die Seriennummer spielt eine wichtige Rolle im Zusammenspiel
zwischen Master-DNS und Slave-DNS: Slaves führen nur dann einen Zonentransfer
durch, wenn die vom Master übermittelte Seriennummer größer ist als 
die der lokal gehaltenen Zone. Sie wird meist nach dem Schema yyyymmddnn gebildet: 
yyyy = Jahr (4-stellig), mm = Monat (2-stellig), dd = Tag (2-stellig) und nn die 
Viertelstunde (2-stellig) des aktuellen Tags.
</li><li>Der Refresh-Wert legt fest, wie häufig ein Slave beim Master
nachfragt, ob sich die Zone verändert hat.
</li><li>Der Retry-Wert legt fest, wie häufig ein Slave einen fehlgeschlagenen 
Zonentransfer wiederholt, bis er aufgibt.
</li><li>Der Expire-Wert legt fest, wie lange ein Slave seine Kopie einer
Zone noch als gültig ansieht, wenn er den Master nicht erreichen kann.
</li><li>Der Minimum-TTL-Wert legt fest, wie lange eine negative Antwort vom
Client zwischengespeichert werden darf. Er ist einer der beiden
wichtigsten Timer in einer Zonendatei (TTL = Time To Live).
</li><li>Der Eintrag in der $TTL-Zeile oberhalb des SOA-Records  legt fest, 
welche Lebensdauer die Resource Records des Zonefiles in den Caches nicht 
authoritativer Nameserver haben sollen.
</li></ul>
Um die Last auf den für eine Zone authoritativen Nameservern zu
verringern, speichern die von den Internetbenutzern verwendeten
Forwarder die Auskünfte, die sie von den authoritativen Nameservern
erhalten haben, für eine bestimmte Zeit zwischen. Der für die Zone
zuständige Administrator kann das Caching der Forwarder in manchen
Grenzen beeinflussen.
<p>
Wird eine Nameserver-Anfrage positiv beantwortet, übermittelt der
authoritative Nameserver zusammen mit dem angefragten Resource Record
die gewünschte Lebenszeit des Eintrags in Form der TTL. Ist im
Zonefile für den Resource Record keine TTL angegeben, so übermittelt
der authoritative Nameserver den mit $TTL im Zonefile gesetzten
Defaultwert.
Der Forwarder übermittelt die Antwort weiter an die Quelle der Anfrage
und speichert die Antwort für die übermittelte Zeitdauer zwischen, so
dass weitere Anfragen nach dem gleichen Resource Record innerhalb
dieser Zeitdauer ohne erneuten Zugriff auf den authoritativen Server
beantwortet werden können.
</p><p>
Bevor man zeitkritische Änderungen an einer Zone vornimmt (z.B. Umzug
eines Web- oder Mailservers auf eine andere IP-Adresse), ist zu
empfehlen, zuerst einen oder beide TTL-Werte herunterzusetzen. Dies
sollte mindestens einen TTL-Zeitraum vor der eigentlichen Änderung
geschehen, damit die kürzere TTL sich herumgesprochen hat. Nachdem die
Änderung erfolgreich durchgeführt wurde, kann die TTL wieder
heraufgesetzt werden.
</p><p>
</p><h4>Der MX-Record</h4>
Nimmt eine Domain am E-Mailverkehr teil, so wird einer oder mehrere MX-Records 
in die Zone eingetragen. MX-Records haben zusätzlich zu ihrem Ziel eine 
Prioritätsangabe. soll eine E-Mail an die Domain zugestellt werden, 
versucht der absendende Mailserver zuerst den MX-Record niedrigster Priorität. 
Kann er die E-Mail dort nicht ausliefern, versucht er der Reihe nach die 
MX-Records höherer Priorität.
<p>
Gibt es für einen Domainnamen keinen MX-Record, sondern nur einen
A-Record, wird die Mail an diesen zugestellt. Dieses Verhalten ist
historisch bedingt und nicht mehr sinnvoll. Trotzdem wird es
immer noch so gehandhabt. Soll eine Domain nicht am E-Mailverkehr
teilnehmen, so ist es sinnvoll, einen MX-Record auf ein System zu
setzen, das für den Domainnamen eingehende E-Mail mit einem 
permanenten Fehler ablehnt.
</p><p>

</p><h2><a name="8.10">Netzwerkkonfiguration am Beispiel Linux</a></h2>
Eigentlich ist es egal, welches Betriebssysem als Beispiel genommen wird -
die Netzkonfiguration ist in etwa immer gleich. Auch viele der unten 
erwähnten Dateien finden sich z. B. bei Windows. Linux dient
deshalb als Beispiel, weil man hier nicht nur irgendwelche Fenster anklickt,
sondern sehen kann, wie mit ein paar Kommandos das Netzwerkinterface eingebunden
wird und welche Effekte auf welche Art und Weise erzielt werden. 
Die wichtigsten Dateien, Bezeichnungen und Anwendungen: 
<p></p><ul>
<li><tt>/etc/HOSTNAME</tt> oder <tt>/etc/hostname</tt>
</li><li><tt>/etc/hosts</tt>
</li><li><tt>/etc/networks</tt>
</li><li><tt>/etc/host.conf</tt>
</li><li><tt>/etc/resolv.conf</tt>
</li><li><tt>/etc/nsswitch.conf</tt>
</li><li><b>ifconfig</b>
</li><li><b>route</b>
</li><li><b>netstat</b>
</li><li><b>ping</b>
</li><li><b>traceroute</b>
</li></ul>

Netzwerkkonfiguration läuft im Normalbetrieb immer automatisch beim
Systemstart ab. Init-Scripts übernehmen die Konfiguration der
Schnittstellen, das Anlegen der Routen und vieles mehr. Trotzdem ist das 
Wissen um die manuelle Konfiguration wichtig, erstens für Problemlösungen
und zweitens, weil damit auf die Schnelle auch eine Umkonfiguration von
Netzwerkkarten oder ein experimenteller Aufbau möglich ist. 
<p>

Auf den (Hardware-)Treiber des Netzwerk-Interface wird aus diesem Grund nicht 
eingegangen. Um festzustellen, ob überhaupt ein Treiber geladen wurde, 
genügt das Kommando
</p><pre>dmesg | more
</pre>
das alle Boot-Meldungen auflistet. Darin findet man auch die Meldungen zur 
Netzwerkkarte, z.B.:
<pre>...

8139cp 10/100 PCI Ethernet driver v0.0.6 (Nov 19, 2001)
8139cp: pci dev 00:0f.0 (id 10ec:8139 rev 10) is not an 8139C+ compatible chip
8139cp: Try the "8139too" driver instead.
8139too Fast Ethernet driver 0.9.24
PCI: Found IRQ 9 for device 00:0f.0
eth0: RealTek RTL8139 Fast Ethernet at 0xe081af00, 00:00:e8:76:2f:ea, IRQ 9
eth0:  Identified 8139 chip type 'RTL-8139A'

...
</pre>
Aus dieser Meldung ist auch die MAC-Adresse des Netzwerk-Interface ablesbar
(im Beispiel: 00:00:e8:76:2f:ea).
<p>
Im Folgenden werden die wichtigsten Konfigurationsdateien für das Netz
besprochen, wobei viele der Dateien - eventuell leicht modifiziert oder
mit ähnlichem Nanen - auch bei Windows zu finden sind. Bei Linux
findet man diese Daten traditionsgemäß im Verzeichnis <i>/etc</i>.
</p><p>

</p><h3>Setzen des Hostnamens</h3>
Die Netzwerksoftware verläßen sich darauf, daß der Name der 
Maschine einen sinnvollen Wert hat. Er wird im Normalfall während 
des Boot-Vorgangs mit dem Befehl <i>hostname</i> gesetzt. Um den 
Hostnamen auf name zu setzen, geben Sie folgendes ein:
<pre>hostname <i>name</i>
</pre>
Es ist üblich, nur den Host-Namen ohne jede Domain-Angabe zu verwenden. 
<p>

</p><h3>/etc/hosts</h3>
In dieser Datei werden die Systeme des Netzwerks mit ihrem Systemnamen und 
die dazu gehörenden Internet-Adressen aufgelistet. 
Auch, wenn man im normalen Betrieb DNS einsetzt, sollte man einen Teil der 
Rechnernamen in <i>/etc/hosts</i> eintragen. Oft möchte man nämlich auch während 
des Bootens, wenn noch keine Netzwerkschnittstellen aktiv sind, symbolische 
Namen verwenden. 
<p>
Um sicherzustellen, daß alle Programme ausschließlich <i>/etc/hosts</i> verwenden, 
um die Adresse eines Systems zu suchen, müssen Sie ggf. die Datei <i>/etc/nsswitch.conf</i> 
editieren. Interessant ist die Zeile, die mit "hosts:" beginnt. Dort sollte "files dns" stehen,
was bedeutet, daß erst in der lokalen Datei <i>/etc/hosts</i> nachgesehen und dann erst 
ein Nameserver kontaktiert wird. Typischerweise sieht die Datei im Ausschnitt so aus:
</p><pre># /etc/nsswitch.conf
#
...
hosts:          files dns
networks:       files
...

</pre>
Auf diese Datei wird weiter unten noch genauer eingegangen.
<p>
Die Datei <i>hosts</i> enthält einen Eintrag pro Zeile, bestehend aus der IP-Adresse, 
dem Hostnamen und einer optionalen Liste von Aliasen für den Hostnamen. Die Felder 
sind durch Leerzeichen oder Tabulatoren voneinander getrennt, und das Adreßfeld muß 
in Spalte eins beginnen. Ein Doppelkreuz (#) leitet immer einen Kommentar ein.
</p><p>
Namen können entweder mit voller Domainangabe (Full Qualified Domain Name, FQDN) 
oder relativ zur lokalen Domain sein. So ist das System sowohl unter seinem offiziellen 
als auch unter dem kürzeren lokalen Namen bekannt. Man kann in der Datei auch die 
Namen und IP-Adressen beliebiger anderer Rechner eintragen. Immer notwendig ist der 
Eintrag für den Rechner selbst, "<tt>127.0.0.1 localhost</tt>",
denn sonst funktionieren gewisse Dienste (z.B. lpd) nicht. 
</p><p>
Für alle folgenden Beispiele werden für die Rechnernamen Schneewittchen und die
sieben Zwerge (in der englischen Fassung von Walt Disney) verwendet. Damit keine
Kollision mit real existierenden Internet-Domains auftreten, kann man als
Domainnamen beispielsweise "<tt>zwerge.local</tt>" nehmen. Als Netz verwenden 
wir das private B-Netz <tt>172.20.y.x</tt> - und davon sogar nur ein C-Subnetz, 
<tt>172.20.20.x</tt>.
</p><p>
Das folgende Beispiel zeigt, wie die Datei <i>/etc/hosts</i> im Zwergenwald 
aussehen könnte. 
</p><pre># 
# Hostdatei fuer Snowwhite and Friends
# 
# IP            FQDN                        Aliase 
127.0.0.1       localhost

# die Zwerge
10.27.210.17    snowwhite.zwerge.local    snowwhite
10.27.210.18    doc.zwerge.local          doc
10.27.210.19    happy.zwerge.local        happy
10.27.210.20    bashful.zwerge.local      bashful
10.27.210.21    sneezy.zwerge.local       sneezy
10.27.210.22    sleepy.zwerge.local       sleepy
10.27.210.23    grumpy.zwerge.local       grumpy
10.27.210.24    dopey.zwerge.local        dopey
...
</pre>

Nach der Internet-Adresse wird der "offizielle" Name des Systems angegeben, gefolgt von 
Alias-Namen für dieses System. Wird als Argument für ein Netzwerk-Kommando ein Name 
angegeben, so wird in dieser Datei die zugehörige Internet-Adresse ermittelt. Erst 
über die Adresse wird eine Verbindung zum Zielsystem aufgebaut. Die Datei <tt>/etc/hosts</tt> 
wird jedoch auch für den umgekehrten Vorgang benutzt. Mit einem
IP-Datagram wird nur die Internet-Adresse des sendenden Systems mitgeschickt. Soll 
nun der zugehörige Name ermittelt werden, so geschieht dies ebenfalls mittels dieser 
Datei. Das Resultat ist jedoch immer der "offizielle" Name des Systems. Deshalb ist 
darauf zu achten, daß stets dieser Name verwendet werden muß, wenn ein Rechnername 
in weiteren Konfigurationsdateien eingetragen wird. 
<p>
Jetzt wissen Sie auch, daß der Eintrag "<tt>127.0.0.1 www.microsoft.com</tt>" 
in der <i>/etc/hosts</i> beispielsweise zu komischen Effekten führen würde
(welchen?).
</p><p>

</p><h3>/etc/networks</h3>
Genau wie für IP-Adressen möchte man manchmal auch symbolische Namen für 
Netzwerknummern verwenden. Aus diesem Grunde gibt es parallel zu <i>/etc/hosts</i> die 
Datei <i>/etc/networks</i>, die Netzwerknamen auf Netzwerknummern abbildet. Diese
Datei wird nicht unbedingt benötigt.  Im Zwergenwald würden z.B. folgende 
<i>networks</i>-Datei installiert:
<pre># /etc/networks 
zwergenwald      172.20.20.0 
</pre>
Beachten Sie, daß die Namen in <i>networks</i> nicht mit den Hostnamen in der Datei 
<i>hosts</i> übereinstimmen und kollidieren, da manche Programme ansonsten seltsame
Resultate produzieren.
<p>

</p><h3>/etc/protocols</h3>
In dieser Datei sind die Protokollnamen und Protokollnummern der Transportprotokolle 
eingetragen, die das System unterstützt. Dank dieser Datei kann man in vielen
Programmen den symbolischen Namen eines Protokolls anstelle der Nummer angeben.
Jede Zeile der Datei enthält den Namen des Transportprotokolls, die 
Protokollnummer und den Aliasnamen des Protokolls, zum Beispiel:
<pre>ip      0     IP         # internet protocol, pseudo protocol number
icmp    1     ICMP       # internet control message protocol
igmp    2     IGMP       # Internet Group Management
ggp     3     GGP        # gateway-gateway protocol
ipencap 4     IP-ENCAP   # IP encapsulated in IP
tcp     6     TCP        # transmission control protocol
egp     8     EGP        # exterior gateway protocol
udp     17    UDP        # user datagram protocol
...
</pre>
<p>

</p><h3>/etc/services</h3>
In dieser Datei werden die Namen von Netzwerkdiensten sowie die zugehörigen 
Portnummern und Protokollnamen gespeichert Dank dieser Datei kann man in vielen
Programmen den symbolischen Namen eines Dienstes anstelle der Nummer angeben.
Beispiel:
<pre>...
ftp       21  tcp 
ssh       22  tcp
telnet    23  tcp 
smtp      25  tcp 
whois     43  tcp 
domain    53  tcp 
gopher    70  tcp 
finger    79  tcp 
www       80  tcp 
www       80  udp
...
</pre> 
<p>

</p><h3>/etc/nsswitch.conf</h3>
Diese Datei wird auch als "Resolver-Bibliothek" bezeichnet. Der Begriff <i>Resolver</i> 
bezieht sich nicht auf ein spezielles Programm, sondern auf  eine Sammlung 
von Funktionen, die bei Linux zur Standard-C-Bibliothek gehören. Ihre 
wichtigsten Routinen sind <i>gethostbyname(2)</i> und <i>gethostbyaddr(2)</i>, 
die alle zu einem Namen gehörenden IP-Adressen zurückliefern und umgekehrt. 
über die Datei <i>/etc/nsswitch.conf</i> können Sie einstellen, ob Sie die 
gewünschten Informationen in <i>/etc/hosts</i> nachschlagen, DNS-Server befragen 
oder die <i>hosts</i>-Datenbank des Network Information Service (NIS) benutzen wollen.
<p>
In der Datei <i>/etc/nsswitch.conf</i> kann der Systemadministrator eine Vielzahl 
verschiedener Datenbanken konfigurieren. Wir besprechen hier nur diejenigen 
Optionen, die sich auf die Auflösung von Host- und Netzwerk-IP-Adressen beziehen. 
Optionen in <i>/etc/nsswitch.conf</i> müssen in getrennten Zeilen erscheinen, wobei 
die Argumente durch Leerzeichen oder Tabulatorzeichen voneinander getrennt sein 
müssen. Ein Doppelkreuz (#) leitet einen Kommentar ein, der sich bis zum 
Zeilenende erstreckt. Jede Zeile beschreibt einen bestimmten Dienst, z.B. die 
Auflösung von Hostnamen. Das erste Feld jeder Zeile gibt den Namen der Datenbank 
an und endet mit einem Doppelpunkt. Der Rest jeder Zeile enthält Optionen, 
die die Art des Zugriffs auf die betreffende Datenbank regeln. Die folgenden 
Optionen sind verfügbar:
</p><p>
<table border="1" cellpadding="3" cellspacing="0" width="80%"> 
<tbody><tr><td><tt>dns</tt></td><td>
Verwendet das Domain Name System (DNS) zur Auflösung der Adresse. Das macht 
allerdings nur Sinn bei der Auflösung von Hostadressen, nicht von Netzadressen. 
Der Mechanismus benutzt die Datei <i>/etc/resolv.conf</i>.
</td></tr>
<tr><td><tt>files</tt></td><td>
Durchsucht eine lokale Datei nach den Host- oder Netznamen und ihren zugehörigen 
IP-Adressen. Diese Option verwendet die traditionellen Dateien <i>/etc/hosts</i> 
und <i>/etc/networks</i>.
</td></tr>
<tr><td><tt>nis</tt> oder <tt>nisplus</tt></td><td>
Verwendet das Network Information System (NIS) zur Auflösung einer Host- oder 
Netzadresse. 
</td></tr>
</tbody></table>
</p><p>
In der Reihenfolge, in der die Dienste angegeben sind, werden sie auch abgefragt, 
wenn ein Name aufgelöst werden soll. Anspruch genommen, in der sie aufgelistet sind. 
Diese Liste befindet sich in der Datei <i>/etc/nsswitch.conf</i> in dem Abschnitt, 
in dem die Beschreibung der Dienste erfolgt. Die Dienste werden von links nach rechts 
abgefragt, und die Suche wird standardmäßig beendet, wenn ein Wert (oder Name) 
erfolgreich aufgelöst wurde. Zum Beispiel:
</p><pre># /etc/nsswitch.conf 
# 
hosts:          dns files 
networks:       files
</pre> 
Dieses Beispiel veranlaßt das System, Hosts zuerst im DNS zu suchen und wenn dort 
nichts gefunden wird, die Suche in der Datei <i>/etc/hosts</i> fortzusetzen. Um 
Netzwerknamen aufzulösen, wird ausschließlich die Datei <i>/etc/networks</i> 
benutzt.
<p>
Sie können das Suchverhalten noch genauer kontrollieren, indem Sie zusätzlich 
Aktionen (action items) angeben, die festlegen, welche Aktion nach dem jeweils letzten 
Namensauflösungsversuch durchgeführt werden soll. Auf diese Erweiterungen wird
an dieser Stelle nicht weiter eingegangen.
</p><p>

</p><h3>/etc/resolv.conf</h3>
Wenn Sie die Resolver-Bibliothek für die Verwendung von DNS konfigurieren, 
müssen Sie ihr auch mitteilen, welche Server sie benutzen soll. Dafür 
gibt es eine separate Datei namens <i>/etc/resolv.conf</i>. Fehlt diese Datei 
oder ist sie leer, nimmt der Resolver an, daß sich der Name-Server auf 
Ihrem lokalen Host befindet.
Um einen Name-Server auf Ihrem lokalen Host laufen zu lassen, müssen Sie 
ihn separat einrichten. Normalerweise verwendet man einen bereits vorhandenen 
Name-Server. Bei einer Dialup-Verbindung ins Internet wird für gewöhnlich der 
Name-Server des Providers in der Datei <i>/etc/resolv.conf</i> eintragen.
<p>
Die wichtigste Option in <i>/etc/resolv.conf</i> ist daher <i>nameserver</i>, welche 
die Adresse eines Name-Servers angibt. Wenn Sie die Option mehrmals angeben, 
werden die Server in der angegebenen Reihenfolge verwendet. Deshalb sollten Sie 
unbedingt den zuverlässigsten Server an erster Stelle eintragen. Wenn Sie 
keinen Name-Server eintragen, nimmt der Resolver an, daß einer auf der lokalen 
Maschine läuft. Gegenwärtig werden bis zu drei <i>nameserver</i>-Einträge 
in <i>/etc/resolv.conf</i> unterstützt.
</p><p>
Zwei weitere Befehle, <i>domain</i> und <i>search</i>, geben Domainnamen an, 
die der Resolver an einen Namen anhängt, wenn die zugehörige Adresse beim ersten 
Versuch nicht gefunden wird. Mit <i>domain</i> können Sie eine Default-Domain 
angeben, die immer dann angehängt werden soll, wenn ein Name nicht aufgelöst 
werden konnte. Wird dem Resolver z.B. der Name "<i>sleepy</i>" übergeben, findet 
dieser den Namen "<i>sleepy<b>.</b></i>" nicht im DNS, da es eine solche Top-Level-Domain 
nicht gibt. Wird "<i>zwerge.local</i>" als Standarddomäne angegeben, wiederholt der 
Resolver seine Anfrage und hängt diese Standarddomäne an den Hostnamen an. 
Die Abfrage nach "<i>sleepy.zwerge.local</i>" ist nun erfolgreich (natürlich
nur, wenn es einen Nameserver gibt).
</p><p>
Mit der Option <i>search</i> kann eine Suchliste angegeben werden, gewissermaßen
eine Verallgemeinerung der <i>domain</i>-Anweisung. Während bei <i>domain</i> 
nur eine einzelne Domain angeben werden darf, akzeptiert <i>search</i> eine 
ganze Liste davon, deren Einträge alle der Reihe nach durchprobiert werden, 
bis ein gültiger DNS-Eintrag gefunden wird. Die einzelnen Namen der Liste 
müssen durch Leerzeichen oder Tabulatoren voneinander getrennt werden.
</p><p>
Die Befehle <i>search</i> und <i>domain</i> schließen einander aus und dürfen 
höchstens einmal auftauchen. Wenn keiner der beiden Befehle angegeben ist, versucht 
der Resolver, die Default-Domain mit Hilfe der Systemfunktion <i>getdomainname(2)</i> 
aus dem lokalen Hostnamen zu raten. Hat der Hostname keinen Domain-Teil, wird als 
Default-Domain die Root-Domain (<i>.</i>) angenommen.
</p><p>
Werfen Sie einen Blick auf die Datei <i>resolv.conf</i> des Zwergenwaldes:
</p><pre># /etc/resolv.conf 
# Unsere Domain 
domain         zwerge.local 
# 
# Wir benutzen "doc" als zentralen Name-Server: 
nameserver     172.20.20.1
</pre>
Wenn Sie in dieser Konfiguration die Adresse von "<i>dopey</i>" suchen, wird der 
Resolver erst versuchen, "<i>dopey<b>.</b></i>" nachzuschlagen, und wenn das 
fehlschlägt, "<i>dopey.zwerge.local</i>".
<p>

</p><h3>Netzwerk-Konfiguration für IP</h3>
Zur Konfiguration der Ethernet-Schnittstellen und Initialisierung der Routing-Tabelle 
sind zwei Befehle von besonderer Bedeutung, nämlich <i>ifconfig</i> (Interface-Konfiguration) 
und <i>route</i>. 
<p>

</p><h4>Schnittstellenkonfiguration mit dem <tt>ifconfig</tt>-Kommando</h4>
Das Starten von TCP/IP erfolgt (unter Unix) durch Shell-Skripte, die je nach 
Unix-Derivat anders heißen und sich an ganz unterschiedlichen Stellen des jeweiligen 
Dateisystems befinden können (Bei Linux beispielsweise im Verzeichnis <i>/etc/init.d</i>. 
So unterschiedlich die Shell-Skripte auch sein mögen, die Initialisierung 
der Netzwerksoftware erfolgt in jedem Falle durch das <i>ifconfig</i>-Kommando. Hier 
wird auch die Initialisierung der Netzwerkschnittstellen vorgenommen. Dabei gibt es 
folgende Arten von Schnittstellen:
<ul>
<li> das Loopback-Interface,
</li><li> Broadcast-Interfaces und
</li><li> Point-to-Point-Interfaces.
</li></ul>
Das Loopback-Interface ist eine spezielle Schnittstelle, die zum lokalen System 
zurückgeführt. Dies bedeutet, daß alle Daten, die durch das Loopback-Interface 
geschickt werden, wieder im lokalen System empfangen werden, Dieser Mechanismus 
erlaubt eine Kommunikation von lokalen Prozessen über TCP/IP und wird insbesondere 
von TCP/IP-Verwaltungsprozessen, aber auch von anderen Diensten genutzt (so z.B. bei 
Datenbanken). Die Standard-Internet-Adresse der Loopback-Schnittstelle ist 127.0.0.1 
und sollte, obwohl es theoretisch möglich ist, nicht verändert werden. 
<p>
<i>ifconfig</i> dient dazu, eine Schnittstelle für die Netzwerkschicht des Kernels sichtbar 
zu machen. Das beinhaltet die Zuweisung einer IP-Adresse und verschiedener anderer Parameter 
sowie die Aktivierung des Interface, damit der Kernel die IP-Pakete über diese 
Schnittstelle senden und empfangen kann. Die einfachste Art, es aufzurufen, ist: 
</p><pre>ifconfig &lt;interface&gt; &lt;ip-addresse&gt; netmask &lt;maske&gt;
</pre>
Der Befehl weist "interface" die Adresse "ip-adresse" zu und aktiviert es. Alle anderen 
Parameter werden auf Standardwerte gesetzt. Fehlt die Netzmaske (<tt>netmask &lt;maske&gt;</tt>),
wird sie aus der Netzwerkklasse der Adresse abgeleitet; für ein Klasse-B-Netz wäre 
das <i>255.255.0.0</i>. Oftmals besteht das Kommando aber zumindest auf der Netzmaske 
als Parameter. Später dazu mehr.
<p>
Initialisiert wird das Loopback-Interface durch das Kommando:
</p><pre>ifconfig lo 127.0.0.1
</pre>
Sogenannte "Broadcast-Interfaces" sind die üblichen Schnittstellen zu lokalen Netzwerken, 
über die mehrere Systeme erreichbar sind, und über die Broadcasts, also Nachrichten 
an alle, verschickt werden. Es handelt sich dabei um Schnittstellen zu Ethernet und TokenRing. 
Neben der Internet-Adresse werden bei der Initiatisierung des Broadcast-Interfaces auch 
die Netzmaske und die Broadcast-Adresse angegeben:
<p>
<tt>ifconfig eth0 192.168.0.1 netmask 255.255.255.0 broadcast 192.168.0.255</tt>
</p><p>
Neben den Broadcast-Schnittstellen gibt es noch die sogenannten 
Point-to-Point-Schnittstellen. Sie sind dadurch gekennzeichnet, daß man nur über sie 
ein anderes System erreichen kann. Beispiele sind SLIP (Serial Line IP) und das 
Point-to-Point-Protokoll PPP, die Verbindungen über die serielle Schnittstelle oder
per Modem/ISDN-Adapter WAN-Verbindungen zulassen. Die Initialisierung einer 
Point-to-Point-Schnittstelle hat z.B. die folgende Form:
</p><p>
<tt>ifconfig ppp0 192.168.1.1 192.168.1.2 netmask 255.255.255.240</tt>
</p><p>
So eine PPP-Verbindung bildet ein eigenständiges Netzwerk. Sollen mehrere Verbindungen 
kombiniert werden, so muß eine Unterteilung in Subnetze erfolgen. Das heißt, daß eine 
entsprechende Netzmaske gewählt werden muß. 
</p><p>

<i>ifconfig</i> kennt eine ganze Reihe von Optionen. Der allgemeine Programmaufruf lautet:
</p><pre>ifconfig interface [address [parameters]]
</pre>
<i>interface</i> ist der Name der zu konfigurierenden Schnittstelle, und 
<i>address</i> ist die IP-Adresse, die ihr zugewiesen werden soll. Sie 
kann entweder als dotted quad angegeben werden oder als Name, 
den <i>ifconfig</i> in <i>/etc/hosts</i> nachschlägt.
<p>
Ein Aufruf nur mit dem Interface-Namen gibt die Konfiguration des
Interface aus. Wird es ganz ohne Parameter aufgerufen, zeigt es alle 
bisher konfigurierten Schnittstellen an; die Option <b>-a</b> erzwingt
zusätzlich die Anzeige der inaktiven. Beispiel:
</p><pre># ifconfig eth0 
eth0      Link encap 10Mbps Ethernet  HWaddr 00:00:C0:90:B3:42 
          inet addr 172.20.20.2 Bcast 172.20.20.255 Mask 255.255.255.0 
          UP BROADCAST RUNNING  MTU 1500  Metric 0 
          RX packets 3136 errors 217 dropped 7 overrun 26 
          TX packets 1752 errors 25 dropped 0 overrun 0

</pre>
MTU gibt die maximale Blockgröße an.
Die Metrik wird von einigen Betriebssystemen verwendet, um die Kosten einer 
Route zu berechnen. Linux benutzt diesen Wert bisher nicht, definiert ihn 
aber trotzdem aus Gründen der Kompatibilität.
Die Zeilen <tt>RX</tt> und <tt>TX</tt> zeigen an, wie viele Pakete empfangen 
(RX - <i>receive</i>) bzw. gesendet wurden (TX - <i>transmit</i>), wie viele 
Fehler dabei auftraten, wie viele Pakete verworfen wurden (dropped) und wie 
viele wegen eines überlaufs (overrun) verlorengingen. Ein überlauf beim Empfänger  
tritt dann auf, wenn Pakete schneller hereinkommen, als der Kernel die Interrupts 
bedienen kann. 
<p>
Die folgende Liste zeigt die Parameter, die <i>ifconfig</i> versteht; die Namen 
der zugehörigen Flags stehen in Klammern. Optionen, die eine bestimmte Eigenschaft 
des Interface aktivieren, können mit vorangestelltem Minuszeichen (-) auch benutzt 
werden, um ihn wieder auszuschalten.
</p><p>
<table border="1" cellpadding="3" cellspacing="1" width="90%"> 
<tbody><tr><td><tt>up</tt></td><td>
Aktiviert ein Interface für die IP-Schicht des Kernels. Sie wird impliziert, wenn 
auf der Kommandozeile eine Adresse angegeben ist. Sie kann auch dazu benutzt werden, 
ein Interface zu reaktivieren, wenn es mit der <tt>down</tt>-Option temporär 
deaktiviert wurde. Entspricht den Flags <i>UP</i> und <i>RUNNING</i>.
</td></tr>
<tr><td><tt>down</tt></td><td>
Markiert eine Schnittstelle als inaktiv, d.h. unzugänglich für die Netzwerkschicht. 
Dadurch wird jeglicher IP-Transport durch die Schnittstelle unterbunden. Beachten 
Sie, daß dadurch automatisch alle Routing-Einträge gelöscht werden, die diese 
Schnittstelle verwenden.
</td></tr>

<tr><td><tt>netmask</tt>&nbsp;Maske</td><td>
Weist des Interface eine Subnetzmaske zu. Sie kann entweder als eine 
32-Bit-Hexadezimalzahl (mit führender 0x) oder als dotted quad
(Beispiel: 255.255.255.0) angegeben werden. 
</td></tr>
<tr><td><tt>pointopoint</tt>&nbsp;Adresse</td><td>
Wird für Punkt-zu-Punkt-Verbindungen benutzt, die nur zwei Hosts miteinander 
verbinden. Sie wird beispielsweise für die Konfiguration von SLIP- und 
PLIP-Schnittstellen benötigt und teilt dem Kernel die IP-Adresse des 
anderen Systems mit. Falls eine Punkt-zu-Punkt-Adresse gesetzt wurde, 
zeigt <i>ifconfig</i> das <i>POINTOPOINT</i>-Flag an ("pointopoint" wird 
wirklich so geschrieben).
</td></tr>
<tr><td><tt>broadcast</tt>&nbsp;Adresse</td><td>
Die Broadcast-Adresse wird normalerweise aus der Netzwerknummer gebildet, 
indem alle Bits des Hostanteils auf eins gesetzt werden. Einige IP-Implementierungen 
verwenden dagegen eine Broadcast-Adresse, bei der die Bits des Hostteils auf null 
gesetzt sind. Die Option <b>broadcast</b> dient dazu, Ihre Konfiguration an eine derartige 
Umgebung anzupassen. Wenn dem Interface eine Broadcast-Adresse zugeordnet wurde, 
gibt <i>ifconfig</i> das Flag <i>BROADCAST</i> aus.
</td></tr>
<tr><td><tt>metric</tt>&nbsp;Wert</td><td>
Dem Routing-Tabellen-Eintrag des Interface einen Metrikwert zuordnen. Dieser Wert 
wird beispielsweise vom <i>Routing Information Protocol</i> (RIP) berücksichtigt, wenn 
es Routing-Tabellen für Ihr Netz erstellt. Die Default-Metrik, die <i>ifconfig</i> 
einem Interface zuweist, ist 0. Wenn Sie das Routing in Ihrem Netz nicht mit RIP 
regeln, benötigen Sie diese Option nicht; aber auch sonst wird die Option
selten benutzt.
</td></tr>
<tr><td><tt>mtu</tt>&nbsp;Bytes</td><td>
Setzen der <i>Maximum Transmission Unit</i> (MTU), d.h. die maximale Anzahl von 
Bytes, die das Interface in einer Transaktion behandeln kann. Für Ethernets liegt 
der Defaultwert bei 1500; für SLIP beträgt er 296. 
</td></tr>
<tr><td><tt>arp</tt></td><td>
Kann nur für Broadcast-fähige Netz wie Ethernet verwendet werden. Ermöglicht 
die Benutzung von ARP zur Zuordnung von IP-Adressen zu physikalischen Adressen. 
Für Broadcast-Netze wird sie per Voreinstellung eingeschaltet. Ist ARP 
abgeschaltet, zeigt <i>ifconfig</i> das <b>NOARP</b>-Flag an.
<tt>-arp</tt> schaltet ARP explizit aus.
</td></tr>
<tr><td><tt>promisc</tt></td><td>
Versetzt die Schnittstelle in den promiscous mode. Auf Broadcast-Netzen hat 
das zur Folge, daß die Schnittstelle alle Pakete unabhängig davon empfängt, 
ob sie für einen anderen Host bestimmt sind oder nicht. Dadurch kann man den 
Netzwerkverkehr mit Paketfiltern wie <i>tcpdump</i> analysieren.
<tt>-promisc</tt> schaltet den Modus ab.
</td></tr>

<tr><td><tt>allmulti</tt></td><td>
Multicast-Adressen sind wie Ethernet-Broadcast-Adressen, mit der Einschränkung, 
daß sie nicht automatisch jeden möglichen Adressaten berücksichtigen, sondern 
nur solche, die ausdrücklich zum Empfang vorgesehen (programmiert) sind. Sie 
eignen sich besonders für Anwendungen wie Ethernet-basierte Videokonferenzen 
oder Audioübertragungen übers Netz, die nur an Interessierte gerichtet sind. 
<tt>-allmulti</tt> schaltet Multicast-Adressen ab.
</td></tr>
</tbody></table>
</p><p>

</p><h4>Das route-Kommmando</h4>
<i>route</i> erlaubt es Ihnen, Routen in die Routing-Tabelle des Kernels einzutragen oder 
aus ihr zu entfernen. Es kann aufgerufen werden als:
<pre>route [add|del] [-net|-host] &lt;target&gt; [dev &lt;if&gt;]
</pre>
Dabei bestimmen die Argumente <b>add</b> bzw. <b>del</b>, ob die Route zu <i>target</i> 
eingetragen bzw. aus <i>target</i> entfernt wird. Die Optionen <b>-net</b> und <b>-host</b> 
teilen dem route-Kommando mit, ob target ein Netzwerk oder ein Hostrechner ist 
(letzteres wird angenommen, wenn Sie hier nichts angeben). Das Argument <i><b>dev </b>if</i> ist optional 
und erlaubt Ihnen die Angabe einer Netzwerkschnittstelle, an die die Route gerichtet werden soll. 
Wenn Sie dem Kernel keine Informationen darüber geben, versucht er selbst, ein sinnvolles Argument 
herauszufinden. 
<p>

</p><h4>Den Rechner konfigurieren</h4>
Das allererste Interface, die aktiviert werden muß, ist das Loopback-Interface:
<pre>ifconfig lo 127.0.0.1
</pre>
<p>
Manchmal wird anstelle der IP-Adresse auch der Name <i>localhost</i> verwendet. Der Befehl 
<i>ifconfig</i> sucht diesen Namen in der Datei <i>/etc/hosts</i>, wo er als Hostname für 
<i>127.0.0.1</i> definiert sein muß.
</p><p>
Zur Anzeige der Konfiguration eines Interface rufen Sie <i>ifconfig</i> mit dem Namen 
des Interface auf. Ganz ohne Parameter wird die Konfiguration aller Interfaces gezeigt:
</p><pre>ifconfig lo 
lo        Link encap:Local Loopback 
          inet addr:127.0.0.1  Mask:255.0.0.0 
          UP LOOPBACK RUNNING  MTU:3924  Metric:1 
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0 
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 
          Collisions:0
</pre>
<p>
Nun fehlt noch ein Eintrag in der Routing-Tabelle, der festlegt, daß dieses Interface als 
Route für das Zielsystem <i>127.0.0.1</i> dient. Dazu geben Sie folgendes ein:
</p><pre>route add 127.0.0.1
</pre>
Es kann auch hier wieder anstelle der IP-Adresse der Namen <i>localhost</i> verwendet werden
(sofern er in <i>/etc/hosts</i> eingetragen ist).
<p>
Es wäre auch möglich, das Netz von <i>localhost</i> einzutragen:
</p><pre>route add -net 127.0.0.0
</pre>
Als nächstes wird mit dem Programm <i>ping</i> getestet, ob alles einwandfrei funktioniert:
<pre>ping localhost
PING localhost (127.0.0.1): 56 data bytes 
64 bytes from 127.0.0.1: icmp_seq=0 ttl=255 time=0.4 ms 
64 bytes from 127.0.0.1: icmp_seq=1 ttl=255 time=0.4 ms 
64 bytes from 127.0.0.1: icmp_seq=2 ttl=255 time=0.4 ms 
^C 
--- localhost ping statistics --- 

3 packets transmitted, 3 packets received, 0% packet loss 
round-trip min/avg/max = 0.4/0.4/0.4 ms
</pre>
Pakete an <i>127.0.0.1</i> werden also korrekt ausgeliefert und es erfolgt sofort eine Antwort. 
Das beweist, daß die erste Netzwerkschnittstelle erfolgreich konfiguriert wurde.
<p>
Die bisher beschriebenen Schritte reichen aus, um Netzwerk-Programme auf einem alleinstehenden 
Rechner zu benutzen. Die oben angegebenen Zeilen müssen in das Netzwerk-Initialisierungsskript 
eingetragen werden, damit sie beim Systemstart ausgeführt werden. In der Regel wird zumindest
die Konfiguration von "lo" beim Installieren des Systems bereits erledigt. Zur Einstimmung 
war das obige aber keine schlechte Übung. Nun sollte zum Beispiel <i>telnet localhost</i> 
eine <i>telnet</i>-Verbindung aufbauen und Ihnen den Login-Prompt Ihres Systems geben.
</p><p>
Die Konfiguration von Ethernet-Schnittstellen geht fast genauso vonstatten wie eben. Man 
braucht nur ein paar Parameter mehr, um auch Subnetze verwenden zu können.
</p><p>
Im Zwergenwald wird vom Klasse-B-Netz nur ein C-Subnetz verwendet. Um 
dies dem Interface mitzuteilen, sieht der <i>ifconfig</i>-Aufruf so aus:
</p><pre>ifconfig eth0 172.20.20.2 netmask 255.255.255.0
</pre>
oder unter Verwendung des Namens aus <i>/etc/hosts</i>:
<pre>ifconfig eth0 doc netmask 255.255.255.0
</pre>
Dies weist des Interface <i>eth0</i> die IP-Adresse von <i>doc</i> (<i>172.20.20.2</i>) zu. 
Hätte man die Netzmaske weggelassen, wäre sie von <i>ifconfig</i> aus der Netzklasse der 
Adresse abgeleitet worden, was den inkorrekten Wert von <i>255.255.0.0</i> ergeben hätte. 
Ein schneller Test ergibt jetzt:
<pre>ifconfig eth0
eth0      Link encap 10Mps Ethernet HWaddr  00:00:C0:90:B3:42 
          inet addr 172.20.20.2 Bcast 172.20.20.255 Mask 255.255.255.0 
          UP BROADCAST RUNNING  MTU 1500  Metric 1 
          RX packets 0 errors 0 dropped 0 overrun 0 
          TX packets 0 errors 0 dropped 0 overrun 0
</pre>
<i>ifconfig</i> hat die Broadcast-Adresse (im <tt>Bcast</tt>-Feld angezeigt) automatisch auf 
den passenden Wert gesetzt, nämlich die Netzwerknummer mit einem Hostteil, bei dem alle 
Bits auf eins gesetzt sind. Außerdem wurde die maximale übertragungseinheit (MTU = <i>Maximum 
Transmission Unit</i>, die maximale Größe der IP-Pakete) auf das Ethernet-spezifische Maximum 
von 1.500 Bytes eingestellt. 
<p>
Wie bereits bei der Loopback-Schnittstelle muß noch eine Route eingetragen werden. Für den 
Zwergenwald gilt:
</p><pre>route add -net 172.20.20.0
</pre>
Damit ist eine Route definiert, die alle Pakete, die ans Netz 172.20.20.0
gerichtet sind an die Ethernetkarte schickt. Das weiß das System, weil die
Ethernetkarte ja die Adresse 172.20.20.2 hat, also die gleiche
Netzadresse. Dieser Befehl ist bei modernen Versionen von <b>ifconfig</b>
unnötig geworden, weil diese Route eben automatisch bei der Konfiguration
angelegt wird.
<p>
Vielleicht haben Sie bemerkt, daß die Angabe des Interface fehlt. Der Kernel prüft alle bisher 
konfigurierten Interfaces und vergleicht das Zielnetz (in unserem Fall <i>172.20.20.0</i>) mit 
der Netznummer der Interface-Adresse, d.h. dem bitweisen UND der Interface-Adresse und der 
Netzmaske. Die einzige Schnittstelle, bei der diese beiden Werte übereinstimmen, ist <i>eth0</i>.
</p><p>
Die Option <b>-net</b> ist nötig, da <i>route</i> sowohl Routen zu Netzwerken 
als auch zu einzelnen Hosts einrichten kann. Wenn man <i>route</i> eine IP-Adresse 
übergibt, versucht das Kommando festzustellen, ob es sich dabei um eine Host- oder Netzadresse 
handelt, indem es den Hostteil betrachtet. Ist der Hostteil null, wird angenommen, daß es sich um
eine Netz-Adresse handelt, andernfalls ist es eine Hostadresse. Deshalb würde <i>route</i> in 
unserem Beispiel davon ausgehen, daß <tt>172.20.20.0</tt> eine Hostadresse ist (Netz: 
<tt>172.20.0.0</tt>, Host: <tt>...20.0</tt>). Da ein Subnetz verwendet wird, braucht das
<i>route-</i>Kommando den Parameter "-net".
</p><p>
Unter Verwendung des Eintrags in <i>/etc/networks</i> wird das Kommando einfacher:
</p><pre>route add zwergenwald
</pre>
<p>
Nun sollte man überprüfen, ob das Ethernet tatsächlich arbeitet. Wählen Sie irgendeine 
bereits konfigurierte Maschine auf Ihrem lokalen Ethernet, z.B. <i>grumpy</i>, und 
geben Sie folgenden Befehl ein:
</p><pre># ping grumpy 
PING grumpy: 64 byte packets 
64 bytes from 172.20.20.1: icmp_seq=0. time=10. ms 
64 bytes from 172.20.20.1: icmp_seq=1. time=7. ms 
64 bytes from 172.20.20.1: icmp_seq=2. time=8. ms 
^C 

----doc.zwerge.local PING Statistics---- 

4 packets transmitted, 4 packets received, 0 packets lost
</pre>

Wenn <i>ping</i> keinerlei Antwort bekommt, sollten Sie die Schnittstellenkonfiguration 
mit <i>netstat</i> überprüfen. Die Paketstatistiken, die <i>ifconfig</i> ausgibt, geben
an, ob überhaupt Pakete über das Interface übertragen wurden. Zusätzlich sollten Sie 
auf beiden Maschinen mit <i>route</i> die Routing-Informationen überprüfen. Wenn 
Sie <i>route</i> ohne weitere Parameter aufrufen, gibt es die Routing-Tabellen aus. 
Die Option <i>-n</i> sorgt dafür, daß es Adressen numerisch anstelle der 
symbolischen Hostnamen darstellt:
<pre>route -n 
Kernel routing table 
Destination  Gateway  Genmask         Flags Metric Ref Use    Iface 
127.0.0.1    *        255.255.255.255 UH    1      0   112    lo 
172.20.20.0   *       255.255.255.0   U     1      0    10    eth0
</pre>
<p>

Die Spalte "Flags" enthält eine Liste von Flags für jedes Interface. <i>U</i> ist 
für aktive Schnittstellen immer gesetzt. Ein Flag <i>H</i> in dieser Spalte besagt, 
daß die Zieladresse einen einzelnen Host bezeichnet. Wenn eine eingetragene Route 
benutzt wird, ändert sich der Wert im <i>Use</i>-Feld ständig.
</p><p>
Bisher wurde eine Maschine auf einem isolierten Ethernet eingerichtet (z.B. in
einem Heimnetz). Der Regelfall ist allerdings, daß mehrere Netze durch Gateways 
miteinander verbunden sind (man will ja auch "nach draußen"). Diese Gateways 
verbinden zwei oder mehrere Ethernets miteinander, oder sie stellen das Tor zum
Internet bereit. Um einen Gateway zu nutzen, muß der Netzwerkschicht zusätzliche 
Routing-Informationen zur Verfügung stehen.
</p>
<p>
Zum Beispiel sind die Ethernets des Zwergenwaldes und des Feenreichs durch solch 
ein Gateway miteinander verbunden, nämlich <i>doc</i>, der bereits konfiguriert 
sei. Auf allen Maschinen des Zwergenwaldes muß nur noch eine weitere Route 
eingetragen werden, die angibt, daß alle Maschinen im Netzwerk der Feen über 
<i>doc</i> erreichbar sind. Der entsprechende Aufruf von <i>route</i> sieht so aus
(sofern <tt>feenreich</tt> in <i>/etc/networks</i> eingetragen wurde):
</p><pre>route add feenreich gw doc
</pre>
Dabei gibt <i>gw</i> an, daß das folgende Argument ein Gateway bezeichnet. 
Natürlich muß jedes System im Feen-Netz, zu dem Sie Verbindung aufnehmen wollen, 
einen analogen Routing-Eintrag für das Zwergen-Netz haben. Sonst könnten Sie 
nur Daten vom Zwergen-Netz an das Feen-Netz senden, die Rechner im Feen-Netz 
wären aber zu keiner Antwort fähig.
<p>
Das war nun ein Gateway, das Pakete zwischen zwei isolierten Netzen befördert. 
Nehmen Sie nun an, daß <i>doc</i> außerdem eine Verbindung ins Internet hat. 
Dann wäre es wünschenswert, daß Pakete für <i>beliebige</i> Zieladressen, die 
nicht im Zwergen-Netz liegen, an <i>doc</i> weitergereicht werden. Das erreicht 
man, indem <i>doc</i> zum Default-Gateway wird:
</p><pre>route add default gw doc                 oder
route add default gw 172.20.20.1         bei Angabe der IP-Adresse
</pre>
Die Netzwerkadresse <i>default</i> ist eine Abkürzung für <i>0.0.0.0</i>, die 
Default-Route. Sie paßt zu jeder Zieladresse und wird immer dann benutzt, wenn 
keine andere eingetragene Route paßt. 
<p>
Es ist ziemlich einfach, eine Maschine als Gateway einzurichten. Nehmen wir an, 
wir befänden uns wieder auf <i>doc</i>, der mit zwei Ethernet-Karten ausgestattet 
ist, die jeweils mit einem der beiden Netze verbunden sind. Man muß nur beide 
Schnittstellen getrennt konfigurieren und ihnen eine Adresse auf dem jeweiligen 
Subnetz zuzuweisen. Dabei ist es recht nützlich, zusätzlich zum offiziellen 
Hostnamen <i>doc</i> zwei Namen für die beiden Schnittstellen in 
<i>/etc/hosts</i> zu definieren:
</p><pre>172.20.20.1      doc.zwerge.local    doc   doc-if1 
172.20.21.1      doc-if2
</pre>
<p>
Mit diesen Einträgen lautet die Befehlsreihenfolge für die Einrichtung der 
beiden Interfaces:
</p><pre>ifconfig eth0 doc-if1 ... 
route add zwergenwald 
ifconfig eth1 doc-if2 ...
route add feenreich
</pre>
Damit Pakete überhaupt zwischen den verschiedenen Netzwerkschnittstellen vermittelt 
werden, bedarf es in neueren Kerneln des Kommandos
<pre>echo '1' &gt; /proc/sys/net/ipv4/ip_forward
</pre>
Wenn es dann nicht funktioniert, überprüfen Sie, ob Ihr Kernel mit Unterstützung 
für IP-Forwarding übersetzt wurde. 
<p>
Sie brauchen nicht einmal eine zweite Netzwerkkarte, denn es gibt sogenannte "Device-Aliase".
Dies sind virtuelle Geräte, die mit der gleichen physischen Hardware verbunden sind, jedoch 
gleichzeitig aktiviert werden können, um unterschiedliche IP-Adressen zu haben. Sie werden 
normalerweise mit dem Gerätennahmen gefolgt von einem Doppelpunkt und einer Zahl dargestellt 
(zum Beispiel <i>eth0:1</i>). Wenn Sie einen Alias verwenden, können weder das Interface 
noch der Alias zur Verwendung von DHCP konfiguriert werden. <i>eth0:1</i> ist der erste Alias 
für <i>eth0</i>. Der zweite Alias hätte den Namen <i>eth0:2</i>, usw. Die Befehle 
um beide Netze über eine Netzwerkkarte zu routen, würden lauten:
</p><pre>ifconfig eth0 doc-if1 ... 
route add zwergenwald 
ifconfig eth0:1 doc-if2 ...
route add feenreich
</pre>
<p>
Die Fehlermeldungen des route-Kommandos sind relativ kryptisch. Bei Linux kann - im Gegensatz zu 
anderen Unixen - die Metrik-Angabe entfallen. Man kann mehrere Routen zu einem Ziel (mit identischer 
Netzmaske) eingeben, sofern jeweils ein anderer Gateway angegeben wird.
</p><p>
</p><h4>Fehlermeldungen des route-Kommandos:</h4>
<ul>
<li><b>SIODELRT</b> ist eine Fehlermeldung beim Löschen einer Route (<b>DEL</b>eting a <b>R</b>ou<b>T</b>e)
</li><li><b>SIOADDRT</b> ist eine Fehlermeldung beim Anlegen einer Route (<b>ADD</b>ing a <b>R</b>ou<b>T</b>e)
</li></ul>
<dl>
<p></p><dt><i>SIOCADDRT: Network is unreachable</i>
</dt><dd>
<tt>route add default gw 1.2.3.4</tt><br>
Die angebene Adresse gehört nicht zum eigenen Netzwerk und so kann der Rechner keine
Pakete dorthin weiterleiten.

<p></p></dd><dt><i>SIOCADDRT: File exists</i>
</dt><dd>Die angegebene Route existiert bereits.

<p></p></dd><dt><i>SIOCADDRT: No such device</i>
</dt><dd>Es wurde das Schlüsselwort <i>gw</i> vor der Default-Gateway-Adresse vergessen; also nicht:<br>
<tt>route add -net 10.2.2.76/24  10.1.1.22</tt><br>
sondern:<br>
<tt>route add -net 10.2.2.76/24  gw 10.1.1.22</tt>

<p></p></dd><dt><i>SIOCDELRT No such process</i>
</dt><dd>Versuch, eine Route zu löschen, die nicht existiert.

<p></p></dd><dt><i>SIOCADDRT: Operation not supported by device</i>
</dt><dd>Es wurde das Schlüsselwort <i>gw</i> oder die Gateway-Adresse vergessen; also nicht:<br>
<tt>route add -net 10.0.0.0/8 10.1.1.254</tt> oder<br>
<tt>route add -net 172.23.24.128/25</tt><br>
sondern:<br>
<tt>route add -net 10.0.0.0/8 gw  10.1.1.254</tt> oder<br>
<tt>route add -net 172.23.24.128/25 gw 10.1.1.22</tt>

<p></p></dd><dt><i>SIOCADDRT: Operation not permitted</i>
</dt><dd>Sie arbeiten nicht mit <i>root</i>-Berechtigung.

<p></p></dd><dt><i>SIOCADDRT: Invalid argument</i>
</dt><dd>Falsche Kommandosyntax (z.B. vergessene Netzmaske); also nicht:<br>
<tt>route add -net 10.2.2.0 gw 10.1.1.254</tt> oder<br>
<tt>route del -net 172.23.0.0</tt><br>
sondern:<br>
<tt>route add -net 10.2.2.0 netmask 255.255.255.0 gw 10.1.1.254</tt> oder<br>
<tt>route add -net 10.2.2.0/24 gw 10.1.1.254</tt> bzw.<br>
<tt>route del -net 172.23.0.0/16</tt> oder<br>
<tt>route del -net 172.23.0.0 netmask 255.255.0.0</tt>

<p></p></dd><dt><i>route: netmask doesn't match route address</i>
</dt><dd>Die Netzmaske passt nicht zur Host- und Gateway-Adresse.

<p></p></dd><dt><i>route: netmask 00ffffff doesn't make sense with host route</i>
</dt><dd>Meist wurde der Parameter <i>-net</i> vergessen. Das Kommando nimmt
dann an, dass man eine Host-Route angeben will. Oder man hat bei einer
Host-Route eine Netzmaske angegeben.

<p></p></dd><dt><i><i>addr</i>: Unknown host</i>
</dt><dd>Meist wurde eine falsche Netzmaske angegebn, die das Kommando falsch
interpretiert.

<p></p></dd><dt><i>route: bogus netmask 255.255.255.25</i>
</dt><dd>Die Netzmaske ist falsch angegeben worden (z.B. '25' oder '2555' statt '255').
</dd></dl>
<p>
Anmerkung: Die Syntax des route-Kommandos variiert von System zu System.
</p><p>


</p><h4>Offene Ports und Anwendungen finden mit netstat</h4>
Ein offener Port im Status "Listen" ist ein potientielles Einfallstor 
für Eindringlinge. Auch Trojaner installieren gerne "Backdoors" und 
öffnen dazu einen freien Port. Daher ist es sehr zu empfehlen, sich 
von Zeit zu Zeit die offenen Ports seiner Systeme anzusehen.
<p>
Für eine Kontrolle der offenen Ports ruft man "netstat&nbsp;-nlp" auf.
</p>

<pre>netstat -npl 
Proto Recv-Q Send-Q Local Address        Foreign Address   State   PID/Program name   
tcp        0      0 72.139.238.24:80     0.0.0.0:*         LISTEN  25671/apache        
tcp        0      0 72.139.238.24:21     0.0.0.0:*         LISTEN  16417/ftpd
tcp        0      0 72.139.238.24:22     0.0.0.0:*         LISTEN  1345/sshd           
tcp        0      0 72.139.238.24:25     0.0.0.0:*         LISTEN  26007/exim4         
tcp        0      0 72.139.238.24:443    0.0.0.0:*         LISTEN  1022/apache-ssl     
</pre>

<p>
Das System zeigt mit diesen Parameter nur Ports im Status "Listen" an. 
Zusätzlich wird in der letzten Spalte die Prozessnummer und der Name 
des zuständigen Dämons angezeigt. Alternativ kann unter Linux auch das 
Kommando "lsof" benutzt werden. Mit dem Aufruf 
</p><pre>lsof -i | grep -e LISTEN
</pre> 
wird ebenfalls eine Liste der Ports im Status "Listen" angezeigt.
<p>

</p><h4>Einsatz von nmap</h4>
Zur Kontrolle der offenen Ports eines Host über das Netzwerk benötigt 
man einen Portscanner, z.B. nmap von Fyodor. Der Portscanner nmap kennt 
eine Unmenge von Optionen. Für einen ersten Scan nach offenen TCP-Ports
wird lediglich der Parameter "-sT" und die IP-Adresse des Zielsystems 
benötigt. Damit scannt nmap alle well know TCP-Ports (1-1024) und alle 
Ports aus der Datei etc/services.

<pre>nmap -sT 192.168.1.1

Starting nmap 3.20 ( www.insecure.org/nmap/ ) at 2004-10-16 23:17 CEST
Interesting ports on Router (192.168.1.1):
(The 1610 ports scanned but not shown below are in state: closed)
Port       State       Service
80/tcp     open        http

Nmap run completed -- 1 IP address (1 host up) scanned in 6.533 seconds
</pre>

Der hier untersuchte IP-Host bietet einen Dienst an: HTTP auf TCP-Port 80.
Auf der Maschine läuft also höchstwarscheinlich ein Webserver. Um alle TCP-Ports
von 1 bis 65535 zu untersuchen ruft man nmap mit den Optionen "-sT -p 1-65535" auf.
Mit der Option "-sU" sucht nmap nach offenen UDP-Ports. UDP-Scanning ist allerdings
oftmals sehr langsam. Ursache hierfür ist eine Begrenzung der Anzahl der ICMP-Meldungen 
die ein Host pro Zeiteinheit versendet. Viele Systeme begrenzen die ICMP-Meldungen nach 
RFC 1812. nmap erkennt dieses Verhalten und arbeitet entsprechen langsamer um keine 
Meldungen zu verlieren.
<p>

</p><h4>tcpdump</h4>
Wenn Probleme in einem Netz auftauchen, so kann mit Hilfe des Programms
"tcpdump" jedes einzelne Paket des Netzes protokolliert und analysiert
werden. Dazu wird die Netzwerkkarte in den <i>promisquous-mode</i>
geschaltet.
"tcpdump" zeigt jetzt die empfangenen Paket-Header an und ermöglicht so
eine Diagnose der aufgetretenen Fehler. Die Anwendung ist ziemlich
kompliziert und würde den Rahmen dieses Kapitels sprengen. Es genügt, zu
wissen, daß es dieses Programm gibt und daß es folgendermaßen aufgerufen
wird.
<ul><b>tcpdump</b> <tt>-i</tt> <i>Interface</i></ul>
Damit werden alle Pakete des genannten Interfaces abgehört. Das Interface
wird mit seinem symbolischen Namen angegeben, also beispielsweise
<i>eth0</i>.
<p>
<b>tcpdump</b> hat eine eigene Art Abfragesprache, die Befehle ermöglicht
wie
</p><pre>  tcpdump host blackhole
</pre>
Zeigt nur Pakete an den oder vom Rechner blackhole.
<pre>  tcpdump host doc and grumpy
</pre>
Zeigt nur Pakete, die zwischen den Rechnern doc und grumpy ausgetauscht werden.
<p>


</p><h3>Die ARP-Tabelle</h3>
Bei einigen Netzproblemen kann es aufschlußreich sein, einen Blick auf 
die ARP-Tabelle des Kernels zu werfen oder sie sogar zu verändern. 
Die Kommandozeilenoptionen von ARP lauten:
<pre>arp [-v] [-t hwtype] -a [hostname] 
arp [-v] [-t hwtype] -s hostname hwaddr 
</pre>
Alle hostname-Argumente können als symbolische Hostnamen oder als IP-Adressen angegeben werden.
<p>
Der erste Aufruf gibt den ARP-Eintrag für die angegebene IP-Adresse bzw. Hostnamen aus. 
Fehlt <i>hostname</i>, werden Informationen über alle bekannten Hosts ausgegeben. 
Zum Beispiel ergibt die Ausgabe von <i>arp</i> auf <i>www.netzmafia.de</i> etwa folgendes:
</p><pre>arp
Address                  HWtype  HWaddress           Flags Mask  Iface
129.187.206.254          ether   00:04:DE:FE:78:00   C           eth0
ns.e-technik.fh-muenche  ether   00:07:E9:24:EC:15   C           eth0
proxy1.e-technik.fh-mue  ether   00:07:E9:24:EC:15   C           eth0
web1.e-technik.fh-muenc  ether   00:07:E9:24:EB:F5   C           eth0
</pre>
Die Ausgabe kann mit der <b>-t</b>-Option auch auf bestimmte Hardwaretypen beschränkt werden.
Als Argument geben Sie <i>ether</i>, <i>ax25</i> oder <i>pronet</i> an, was für 10 Mbps Ethernet, 
AMPR AX.25 und IEEE 802.5 Token Ring steht.
<p>
Die Option <b>-s</b> dient dazu, die Hardwareadresse von <i>hostname</i> manuell in die 
ARP-Tabelle einzutragen. Das Argument <i>hwaddr</i> spezifiziert die Hardwareadresse, 
die normalerweise als Ethernet-Adresse aus sechs Byte in hexadezimaler Notation angegeben ist. 
Sie können solche Adressen auch bei anderen Hardwaretypen verwenden, wenn Sie zusätzlich die 
Option <b>-t</b> angeben.
Die Festverdrahtung von Hardwareadressen im ARP-Cache ist eine drastische Maßnahme, um Maschinen 
aus Ihrem Ethernet daran zu hindern, sich als jemand anderes auszugeben.
</p><p>
Wenn Sie <i>arp</i> mit der Option <b>-d</b> aufrufen, entfernt es alle Einträge für einen bestimmten 
Host. Es kann dazu benutzt werden, das Interface anzuweisen, eine bereits angeforderte Hardwareadresse 
einer IP-Adresse nochmals anzufordern, und ist besonders dann nützlich, wenn ein fehlerhaft konfiguriertes 
System falsche ARP-Informationen sendet (natürlich muß zuerst das fehlerhafte System erneut konfiguriert 
werden).
</p><p>


</p><center><table border="0" width="100%">
<tbody><tr>
<td align="LEFT" valign="BOTTOM"><img src="TCP_IP-Dateien/left.gif" border="0"> <a href="https://web.archive.org/web/20070611100850fw_/http://www.netzmafia.de/skripten/netze/twisted.html">Zum vorhergehenden Abschnitt</a></td>
<td align="CENTER" valign="BOTTOM"><img src="TCP_IP-Dateien/up.gif" border="0"> <a href="https://web.archive.org/web/20070611100850fw_/http://www.netzmafia.de/skripten/netze/index.html">Zum Inhaltsverzeichnis</a></td>
<td align="RIGHT" valign="BOTTOM"><img src="TCP_IP-Dateien/right.gif" border="0"> <a href="https://web.archive.org/web/20070611100850fw_/http://www.netzmafia.de/skripten/netze/netz9.html">Zum nächsten Abschnitt</a></td>
</tr></tbody></table></center>
<p></p><hr>
<h6><i>Copyright © FH München, FB 04, Prof. Jürgen Plate</i></h6>
<h6><i>Letzte Aktualisierung: 12. May 2006</i></h6>



</body></html>
<!--
     FILE ARCHIVED ON 10:08:50 Jun 11, 2007 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 05:25:03 May 28, 2025.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  captures_list: 0.769
  exclusion.robots: 0.028
  exclusion.robots.policy: 0.013
  esindex: 0.013
  cdx.remote: 9.024
  LoadShardBlock: 111.881 (3)
  PetaboxLoader3.datanode: 76.744 (4)
  PetaboxLoader3.resolve: 99.637 (2)
  load_resource: 92.401
-->